Java 8 Features

1. Lambda expression − Adds functional processing capability to Java.

2. Method references − Referencing functions by their names instead of invoking them directly. Using functions as parameter.

3. Nashorn, JavaScript Engine − A Java-based engine to execute JavaScript code.

4. Optional − Emphasis on best practices to handle null values properly.

5. Stream API − New stream API to facilitate pipeline processing.

6. Default method − Interface to have default method implementation.

7. Date Time API − Improved date time API.

8. Base64 - Java 8 now has inbuilt encoder and decoder for Base64 encoding.







1. Lambda Expression

A lambda expression is characterized by the syntax           .

 parameter -> expression body

Following are the important characteristics of a lambda expression.

Optional type declaration − No need to declare the type of a parameter. The compiler can inference the same from the value of the parameter.

Optional parenthesis around parameter − No need to declare a single parameter in parenthesis. For multiple parameters, parentheses are required.

Optional curly braces − No need to use curly braces in expression body if the body contains a single statement.

Optional return keyword − The compiler automatically returns the value if the body has a single expression to return the value.

Following are the important points to be considered in the above example.

Lambda expressions are used primarily to define inline implementation of a functional interface, i.e. an interface with a single method only
Lambda expression eliminates the need of anonymous class and gives a very simple functional programming capability to Java.




2. Method references 

Method references help to point to methods by their names. Method reference is used to refer method of functional interface.
A method reference is described using "::" symbol.
A method reference can be used to point the following types of methods −
Static methods
Instance methods
Constructors using new operator (TreeSet::new)

Example 

import java.util.List;
import java.util.ArrayList;

public class Java8Tester {

   public static void main(String args[]) {
      List names = new ArrayList();
		
      names.add("Mahesh");
      names.add("Suresh");
      names.add("Ramesh");
      names.add("Naresh");
      names.add("Kalpesh");
		
      names.forEach(System.out::println);
   }
}



3. Nashorn, JavaScript Engine − A Java-based engine to execute JavaScript code.

4. Optional 

Optional is a container object used to contain not-null objects. Optional object is used to represent null with absent value. 
This class facilitate code to handle values as ‘available’ or ‘not available’ instead of checking null values.


Syntax     public final class Optional<T> extends Object


5. STREAM  API
Stream represents a sequence of objects from a source, which supports aggregate operations.

Using stream, you can process data in a declarative way similar to SQL statements. SELECT max(salary), employee_id, employee_name FROM Employee
The above SQL expression automatically returns the maximum salaried employee's details, without doing any computation on the developer's end. 
Using collections framework in Java, a developer has to use loops and make repeated checks. Another concern is efficiency; 
as multi-core processors are available at ease, a Java developer has to write parallel code processing that can be pretty error-prone.

A stream gets/computes elements on demand. It never stores the elements. Stream takes Collections, Arrays, or I/O resources as input source

Stream supports aggregate operations like filter, map, limit, reduce, find, match,

Stream operations do the iterations internally over the source elements provided, in contrast to Collections where explicit iteration is required.

Example 
Collection interface has two methods to generate a Stream.

stream() − Returns a sequential stream considering collection as its source.

parallelStream() − Returns a parallel Stream considering collection as its source.

List<String> strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl");
List<String> filtered = strings.stream().filter(string -> !string.isEmpty()).collect(Collectors.toList());


forEach
Stream has provided a new method ‘forEach’ to iterate each element of the stream. The following code segment shows how to print 10 random numbers using forEach.

Random random = new Random();
random.ints().limit(10).forEach(System.out::println);

map
The ‘map’ method is used to map each element to its corresponding result. The following code segment prints unique squares of numbers using map.

List<Integer> numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);

//get list of unique squares
List<Integer> squaresList = numbers.stream().map( i -> i*i).distinct().collect(Collectors.toList());


filter
The ‘filter’ method is used to eliminate elements based on a criteria. The following code segment prints a count of empty strings using filter.

List<String>strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl");

//get count of empty string
int count = strings.stream().filter(string -> string.isEmpty()).count();


limit
The ‘limit’ method is used to reduce the size of the stream. The following code segment shows how to print 10 random numbers using limit.

Random random = new Random();
random.ints().limit(10).forEach(System.out::println);


sorted
The ‘sorted’ method is used to sort the stream. The following code segment shows how to print 10 random numbers in a sorted order.

Random random = new Random();
random.ints().limit(10).sorted().forEach(System.out::println);


Parallel Processing
parallelStream is the alternative of stream for parallel processing. Take a look at the following code segment that prints a count of empty strings using parallelStream.

List<String> strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl");

//get count of empty string
long count = strings.parallelStream().filter(string -> string.isEmpty()).count();
It is very easy to switch between sequential and parallel streams.


Collectors
Collectors are used to combine the result of processing on the elements of a stream. Collectors can be used to return a list or a string.

List<String>strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl");
List<String> filtered = strings.stream().filter(string -> !string.isEmpty()).collect(Collectors.toList());

System.out.println("Filtered List: " + filtered);
String mergedString = strings.stream().filter(string -> !string.isEmpty()).collect(Collectors.joining(", "));
System.out.println("Merged String: " + mergedString);


Statistics
With Java 8, statistics collectors are introduced to calculate all statistics when stream processing is being done.

List numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);

IntSummaryStatistics stats = numbers.stream().mapToInt((x) -> x).summaryStatistics();

System.out.println("Highest number in List : " + stats.getMax());
System.out.println("Lowest number in List : " + stats.getMin());
System.out.println("Sum of all numbers : " + stats.getSum());
System.out.println("Average of all numbers : " + stats.getAverage());




6. Default method

This capability is added for backward compatibility so that old interfaces can be used to leverage the lambda expression capability of Java 8.
For example, ‘List’ or ‘Collection’ interfaces do not have ‘forEach’ method declaration. Thus, adding such method will simply break the collection framework implementations


7. Date Time API
a new Date-Time API is introduced to cover the following drawbacks of old date-time API.

Not thread safe − java.util.Date is not thread safe, thus developers have to deal with concurrency issue while using date. 
The new date-time API is immutable and does not have setter methods.
Difficult time zone handling.
important classes introduced in java.time package.

Local − Simplified date-time API with no complexity of timezone handling.

Zoned − Specialized date-time API to deal with various timezones.


8. Base64 

we can use three types of Base64 encoding.

Simple − Output is mapped to a set of characters lying in A-Za-z0-9+/. The encoder does not add any line feed in output,
and the decoder rejects any character other than A-Za-z0-9+/.

URL − Output is mapped to set of characters lying in A-Za-z0-9+_. Output is URL and filename safe.

MIME − Output is mapped to MIME friendly format. Output is represented in lines of no more than 76 characters each, 
and uses a carriage return '\r' followed by a linefeed '\n' as the line separator. No line separator is present to the end of the encoded output.