1. What is the Collection framework in Java?
        Collection Framework is a grouping of classes and interfaces that is used to store and manage the objects.

2. Distinguish between ArrayList and Vector in the Java collection framework.

    ArrayList	                                                  Vector
ArrayList is cannot be synchronized.	          Vector can be is synchronized (only one thread at a time can access the code)
It is fast                                        It is slow.      
ArrayList is not thread-safe.	                  Vector is a thread-safe.
It can increase its size by 50%.	          It can increase its size by doubling the size of the array.
It is not a legacy class.	                  It is a legacy class.

3.              Array                                                                          Arraylist 
    Array is static in size.	                                                ArrayList is dynamic in size.
    It is mandatory to provide the size of an array while using new keyword     We can create an instance of ArrayList without specifying its size. 
     ex:   int[] myArray = new int[6];                                               initial capacity is 10.
           myArray[0] = 3;
    It performs fast because of fixed size.	                                The resize operation slows down the performance.
    stores both objects and primitives type.	                                doesn't store primitive type. It automatically converts primitive type to object.
    length variable to determine the size of an array.	                        size() method to determine the size of ArrayList.
    can add elements in an array by using the assignment operator.	        the add() method to add elements in the ArrayList.


         Arrays class methods are
               import java.util.Arrays;

               int[] numbers = {1, 2, 3, 7, 4, 5};
    String     Arrays.toString(numbers));                      // Output: [1, 2, 3, 7, 4, 5]
    void       Arrays.sort(numbers);                          // Output: [1, 2, 3, 4, 5, 7]
               Arrays.sort(numbers[], Comparator.reverseOrder())           // Sorting the array in descending order. note: it works on object like Integer not on int.
               Arrays.sort(numbers, 3,5);                                 // sorts only numbers falling between fromIndex 3 and toIndex 5


               int[] copy = Arrays.copyOf(numbers, 3);
               Arrays.toString(copy));                         // Output: [1, 2, 3]

               int[][] matrix = {
                                 {1, 2, 3},
                                 {4, 5, 6}
                                };
               Arrays.deepToString(matrix);                    // Output: [[1, 2, 3], [4, 5, 6]]   
               

               int[] array1 = {1, 2, 3};
               int[] array2 = {1, 2, 3};
               Arrays.equals(array1, array2);                    // output: true

               Arrays.binarySearch(numbers, 3);                  // output:  2 which is the index position of the value 3

List methods 
        ArrayList<String> list = new ArrayList<>();
        list.add("Apple");
        list.add("Banana");
        list.add(1, "Orange");                  // Insert "Orange" at index 1 and moves banana to index 2 position.


      list.clear();                          // Clear the list
      list.contains("Apple");               // Check if "Apple" is in the list
      list.size()                          // returns size of the list.
      list.remove(0);                     // Remove the first element
      list.set(1, "Orange");             // Replace "Banana" with "Orange"
      list.get(0);                      // Get the first element

4. The ArrayList size increases dynamically by 50% because whenever the ArrayList class requires to resize then it will create a new array of bigger size and copies all 
    the elements from the old array to the new array. the DEFAULT_CAPACITY is 10.
    example
    ArrayList<String> ar = new ArrayList<>()                           // the default constructor capacity is 10.  
     
    
3. Differentiate between Iterator and ListIterator

    Iterator	                                                                                ListIterator
The Iterator can traverse the array elements in the forward direction.	            ListIterator can traverse the array elements in backward as well as forward directions.
It can be used in Map, List, and Set.                               	            It can be used in List.
It can perform only remove operation.                                             	It can perform add, remove, and set operation while traversing the collection.
Iterator cannot modify or replace elements                                          can modify or replace an element with the help of set(E e)
Indexes cannot be obtained by using Iterator.                                       nextIndex() and previousIndex() helps to obtain indexes of elements at any time.
Cannot add elements and it throws ConcurrentModificationException                   Can add elements to a collection at any time
methods of Iterator are next(), remove() and hasNext()                              methods of ListIterator are next(), previous(), hasNext(), hasPrevious(), add(E e)
example:   Iterator<String> itr = ar.iterator();                                    example: ListIterator<String> itr = ar.listIterator();
           while(itr.hasNext()){                                                             while (itr.hasNext()) {
                System.out.println(itr.next());                                                  System.out.println(itr.next());                                                 


4. 
5. What is the difference between Comparable and Comparator?

      Comparable	                                                                                             Comparator
Comparable provides compareTo() method to sort elements in Java.	                Comparator provides compare() method to sort elements in Java.
Comparable interface is present in java.lang package.	                            Comparator interface is present in java. util package.
It provides single sorting sequences.                                           	It provides multiple sorting sequences.
This method can sort the data according to the natural sorting order.           	This method sorts the data according to the customized sorting order.
It affects the original class. i.e., the actual class is altered.                 	It doesnâ€™t affect the original class, i.e., the actual class is not altered.


8. What is the difference between Hashmap and Hashtable?

        Hashmap	                                                        Hashtable
It is not synchronized.	                                                It is synchronized.
HashMap allows one null key                             	            HashTable does not allow null key.
Iterator is used to traverse HashMap.	                                Either Iterator or Enumerator is used for traversing a HashTable.
It is fail-fast.                                                        It is fail-safe.
faster than HashTable.	                                                slower than HashMap.

9. An easy-to-remember acronym for common Set methods in Java could be "AIS". Here's what each letter represents:
   A: add() - Adds an element to the set.
   I: isEmpty() - Checks if the set is empty.
   S: size() - Returns the number of elements in the set.

10. easy-to-remember acronym for common ArrayList methods in Java could be "CRUD". Here's what each letter represents:
    C: add() - Adds an element to the ArrayList.R: get() - Retrieves an element from the ArrayList based on its index.U: set() - Updates an element in the ArrayList at a specified index.D: remove() - Deletes an element

11. what is hashing? 
    hashing refers to the process of converting an object or data structure into a numerical value, known as a hash code, using a hashing algorithm. 
    Hashing is commonly used for indexing data in HashMap, ensuring data integrity, and optimizing search operations.

12.   Access modifiers
        Private : The member is accessible only within its own class.    POC
        Default (Package-Private): The member is accessible only within its own package.    DOP
        Protected: The member is accessible within its own package and by subclasses of other packages.  ProtOPSOP
