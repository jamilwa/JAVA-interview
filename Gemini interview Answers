
1. What is auto-configuration
Traditionally, setting up a Java application required massive XML files to define how different parts of the app should talk to each other.
With auto-configuration, the framework looks at your classpath. If it sees a database driver (like MySQL) in your project, it "guesses" you want to connect
to a database and automatically sets up a default connection pool for you. 
•	Opinionated Defaults: It assumes "standard" settings so you can start coding immediately.
•	Conditional Logic: It only activates if specific files or libraries are presen

In Spring Boot, auto-configuration is handled by the @EnableAutoConfiguration annotation (usually tucked inside the @SpringBootApplication tag). It essentially 

looks at your classpath (the libraries you've included) and decides which "Beans" or objects it should create for you

Here are the most common areas where Spring Boot handles the heavy lifting:
1. Web & Servlet Containers
If you add the spring-boot-starter-web dependency, Spring Boot assumes you want to build a web application. 
•	Embedded Server: It automatically starts an Apache Tomcat server on port 8080.
•	JSON Mapping: It configures Jackson so that your Java objects are automatically converted to JSON when returned from an API.
•	Static Content: It sets up default locations for your CSS, JS, and HTML files (like /static or /public).

2. Data & Databases
This is where the "magic" is most visible. If you add a database driver to your pom.xml or build.gradle:
•	DataSource: It automatically creates a connection pool (usually HikariCP).
•	Hibernate/JPA: If you’re using Spring Data JPA, it configures the EntityManagerFactory and transaction managers so you can just start using @Repository.
•	In-Memory Databases: If it sees H2 or HSQLDB on the path, it configures an in-memory database automatically for testing.
3. Security
By simply adding spring-boot-starter-security:
•	Default Protection: It secures all your endpoints immediately.

•	Login Form: It generates a default login page.
•	Password: It generates a random security password and prints it to your console.

How it works: "The Conditional Logic"
Spring Boot doesn't just guess blindly; it uses Conditional Annotations. It only provides a configuration if certain conditions are met


@ConditionalOnClass
Only configure this if a specific .class file is found (e.g., MySQL driver).

@ConditionalOnMissingBean
Only create this bean if you haven't already 

created your own.

@ConditionalOnProperty
Only activate if a specific property is set in your application.properties.


2. Default port of Spring Boot
By default, a Spring Boot web application starts on port 8080. 
When you include the spring-boot-starter-web dependency, Spring Boot’s auto-configuration detects an embedded server (like Tomcat) and maps it to this port automatically.
How to change it
If 8080 is already taken (or you just want to be different), you have three main ways to change it:
1. Via Properties File
The most common method is adding a line 

to your src/main/resources/application.properties file:
server.port=9090

2. Via Command Line
If you’ve already built your .jar file, you can override the port at runtime without changing the code:
java -jar my-app.jar --server.port=8081

3. Random Port
If you are running microservices and don't care which port is used (to avoid conflicts), you can use:
server.port=0
This tells Spring Boot to find any available port. You can then find which port was chosen by looking at the console logs during startup.


3. What is starter dependency
a Starter Dependencies are "curated bundle" of libraries that contains a list of other dependencies.
Instead of you having to hunt down every single library needed for a specific task (like building a web API and making sure
their versions are compatible, you just add one "Starter," and Spring Boot pulls in everything else for you.

How it works 
For example, if you add spring-boot-starter-web, you don't just get one file. You automatically get:
•	Jackson (For JSON processing)
•	Tomcat (The embedded web server)
•	Logging (Logback and SLF4J)
•	Spring MVC (The framework)

4. Why spring-boot-starter-parent
In Maven-based Spring Boot projects, the "Parent" is a special project that your project "inherits" from. It doesn’t actually add any code to your app; 
    instead, it sets the rules, versions, and configurations for everything you do. 
1. The "Version Manager" (Dependency Management)
The most important job of the Parent is managing library versions.
•	Without Parent: You’d have to manually specify the version for every single library (e.g., Hibernate 6.1, Jackson 2.15, SnakeYAML 2.0). If you pick versions
    that don't like each other, your 

app crashes.
•	With Parent: You only specify the version of the Spring Boot Parent once. From that point on, you can add starters without version tags.
2. Default Configuration (Sensible Defaults)
The Parent provides pre-configured settings for your build environment: 
•	Java Version: It sets the default Java version (like Java 17 or 21).
•	Resource Filtering: It configures Maven to recognize placeholders like @project.version@ inside your application.properties.
•	UTF-8 Encoding: It ensures your source code is compiled using UTF-8 by default so you don't run into weird character issues.
What if I can't use the Parent?

Sometimes, a large company already has its own "Corporate Parent" POM that your project must inherit from. Since Maven only allows one parent, you can't use the 
    spring-boot-starter-parent. 
In that case, you use a "workaround" called Import Scope. You add the spring-boot-dependencies inside your <dependencyManagement> section. It gives you the version
    management benefits without needing the Parent tag.


5. What is CommandLineRunner 
CommandLineRunner is a simple functional interface used to run a specific piece of code immediately after the application context has fully loaded, but before the
    application finishes starting up. 
It is the go-to tool for "startup tasks." 
How it Works

When you implement CommandLineRunner, you override a single method: run(String... args). Spring Boot automatically detects any bean that implements this interface
    and executes it. 
Common Use Cases
•	Database Seeding: Checking if a database is empty and inserting "Admin" users or reference data.
•	Logging: Printing a specific message to confirm that external services (like a cache or message queue) are reachable.
•	Cleanup: Clearing out temporary folders or old cache files on restart.
•	Reading Arguments: Processing command-line arguments passed when the .jar was executed.
import org.springframework.boot.CommandLineRunner;
import 

org.springframework.stereotype.Component;

@Component
public class MyStartupTask implements CommandLineRunner {

    @Override
    public void run(String... args) throws Exception {
        System.out.println("Hello! The app is up. Checking system status...");
        
        if (args.length > 0) {
            System.out.println("Arguments passed: " + String.join(", ", args));
        }
    }
}

Key Features to Know
•	Access to Arguments: The String... args parameter gives you raw access to whatever you typed in the terminal after java -jar app.jar.
•	The @Order Annotation: If you have multiple CommandLineRunner beans, they might run in a random order. You can use the @Order annotation (e.g., @Order(1), 
    @Order(2)) to tell Spring exactly which task should happen first.
•	Exception Handling: If a CommandLineRunner throws an exception, Spring Boot will consider the startup failed and shut down the application.

6. What is ApplicationRunner
ApplicationRunner is the more "sophisticated" sibling of CommandLineRunner. Like its sibling, it is a 

functional interface used to execute code immediately after the Spring application starts.
The key difference lies in how it handles the inputs you provide when running your application. While CommandLineRunner gives you a messy array of raw strings,
    ApplicationRunner parses those strings into a structured object called ApplicationArguments.

Why use ApplicationRunner?
Imagine you run your application like this:
java -jar myapp.jar --port=9090 --debug logfile.txt
•	CommandLineRunner would give you: ["--port=9090", "--debug", "logfile.txt"]. You’d have to manually split the strings and figure out which is a flag and which
    is a value.
•	ApplicationRunner parses these into 

Option Arguments (port, debug) and Non-Option Arguments (logfile.txt).
Code Example
Here is how you use the parsed arguments 

@Component
public class MyAppStartup implements ApplicationRunner {

    @Override
    public void run(ApplicationArguments args) throws Exception {
        // 1. Check if a flag exists (e.g., --debug)
        boolean debugMode = args.containsOption("debug");
        
        // 2. Get the value of a specific option (e.g., --port=9090)
        if (args.containsOption("port")) {
            System.out.println("Custom port detected: " + args.getOptionValues("port"));

        }
        
        // 3. Get raw arguments that aren't flags (e.g., logfile.txt)
        System.out.println("Files to process: " + args.getNonOptionArgs());
    }
}

Key Capabilities of ApplicationArguments
The ApplicationArguments object provides several helpful methods that CommandLineRunner lacks:
•	getOptionNames(): Returns a set of all flag names passed (e.g., ["port", "debug"]).
•	getOptionValues(name): Returns a list of values for a specific flag (since you can pass --tag=java --tag=python).

•	getSourceArgs(): Gives you the raw string array anyway, just in case you miss the old way.
Which one should you choose?
•	Use CommandLineRunner if you have very simple needs or are just running a quick script.
•	Use ApplicationRunner if your application needs to handle complex command-line inputs, flags, and values properly.

7. What is Actuator 
Actuator is a sub-project that adds "production-ready" features to your application. 
If your application is an engine, the Actuator is the dashboard. It provides a series of built-in HTTP endpoints that allow you to monitor, manage, and interact with
    your application without having to write a 

single line of code for logging or health checks. 
Why do you need it?
When an app moves from your laptop to a real server, you need answers to questions like:
•	Is the app actually running or is it stuck? (Health)
•	How much memory is it using right now? (Metrics)
•	What are the current values of my configuration properties? (Env)
•	Which beans are registered in my Spring Context? (Beans)


Key Endpoints
Once you add the Actuator dependency, these endpoints become available (usually under the /actuator prefix):


/health
Shows application health information (UP/DOWN). It can also check DB and disk space.
/metrics
Shows various metrics like JVM memory, CPU usage, and HTTP request counts.
/env
Displays current environment properties (from application.properties, OS, etc.).
/loggers
Allows you to view and even change logging levels at runtime without restarting.
/threaddump
Performs a thread dump to help debug deadlocks or performance spikes.
/info
Displays arbitrary application info (like build version or git commit ID).


Important: Security & Exposure
By default, for security reasons, only the /health endpoint is exposed over the web. To see others (like /metrics or /env), you have to explicitly "turn them on" in
    your application.properties:  
# Expose all actuator endpoints (Warning: Not for production without security!)
management.endpoints.web.exposure.include=*


Security Tip: Actuator endpoints reveal sensitive details about your server. In a real-world scenario, you should always protect these endpoints using Spring Security
    so only admins can access them.


8. Difference between @component 

In short: @Component is for "Auto-detection," while @Bean is for "Manual-control."

@Component: The "Auto-Scan" Approach
When you put @Component on a class, you are telling Spring: "Hey, keep an eye out for this class. If you find it, please instantiate it and manage it for me."
•	Who creates it? Spring (using Component Scanning).
•	Where is it placed? On the Class level.
•	Use case: When you are writing the code for the class yourself and want Spring to handle it automatically.


When to use which?
•	Use @Component for your everyday 

internal classes: Controllers, Services, and Repositories (using @Service, @Repository, etc., which are just specialized versions of @Component).
•	Use @Bean when you want to make a third-party library (like Jackson, RedisTemplate, or RestTemplate) available as a Spring Bean, or when you need to create different
    versions of the same bean based on environment variables.

9. How does Spring decide which beans to create

Spring uses a process called Application Context initialization to decide which beans to create. It's essentially a massive logic gate that filters through your code,
    your dependencies, and your settings. 
The process happens in three main stages:

1. Component Scanning (The Search)
When you start your app, Spring looks for classes marked with "Stereotype Annotations." It starts at the package where your @SpringBootApplication class is located 
    and scans everything inside it. 
•	Stereotypes: It looks for @Component, @Service, @Repository, and @Controller.
•	The Rule: If it finds one, it puts it on the "to-be-created" list.
2. Java Configuration (The Manual List)
Spring then looks for classes annotated with @Configuration. It executes every method inside those classes marked with @Bean. 
•	The Rule: Whatever the method returns becomes a bean.

3. Auto-Configuration & Conditional Logic (The Smart Guess)
This is the most "magical" part of Spring Boot. It uses a mechanism called Conditional Configuration to decide whether to create a bean based on the environment. 
Spring doesn't just create everything; it asks a series of "questions" using @Conditional annotations:
•	Is the library present? (@ConditionalOnClass): "I'll only create a JdbcTemplate bean if I see the 'DataSource' class in the library folder."
•	Did the user already make one? (@ConditionalOnMissingBean): "I'll create a default ObjectMapper only if the developer hasn't defined their own @Bean of that type."

•	Is a setting turned on? (@ConditionalOnProperty): "I'll only create this EmailService if mail.enabled=true is in the properties file."
•	Where is it running? (@ConditionalOnCloudPlatform): "I'll only create this bean if I'm running on AWS."
4. The Dependency Graph (The Order)
Once Spring has the list of beans to create, it has to figure out the order. It builds a "Dependency Graph."
•	If ServiceA needs RepositoryB in its constructor, Spring knows it must create RepositoryB first.
•	If there is a Circular Dependency (A needs B, and B needs A), Spring will throw an error and stop, because it 

doesn't know where to start.

Summary: The Decision Tree
•	Scan: Find everything with @Component.
•	Config: Find everything with @Bean.
•	Condition: Filter out beans based on @Conditional rules.
•	Sort: Arrange them in order of who needs whom.
•	Instantiate: Create the objects and store them in the ApplicationContext

10. What is @ConfigurationProperties
this annotation is about owning your configuration settings in a clean, type-safe way. 
It is used to bind external properties (from your application.properties or application.yml) directly into a Java object. 

1. The Problem: The @Value Mess
Without @ConfigurationProperties, you usually use @Value to grab settings. If you have 10 settings for a "Mail Service," your code gets messy:  
@Value("${mail.host}") private String host;
@Value("${mail.port}") private int port;
@Value("${mail.username}") private String user;
// ... this becomes a nightmare to maintain.

2. The Solution: @ConfigurationProperties
This annotation groups related properties into a single POJO (Plain Old Java Object). 
Your application.properties:
mail.host=smtp.gmail.com
mail.port=587
mail.username=admin@company.com

Your Java Class:
@Configuration
@ConfigurationProperties(prefix = "mail")
public class MailConfig {
    private String host;
    private int port;
    private String username;

    // Getters and Setters are REQUIRED
    public String getHost() { return host; }
    public void setHost(String host) { this.host = host; }
    // ... etc
}


How to Enable It
In older versions, you had to add @EnableConfigurationProperties(MailConfig.class) to a configuration class. In modern Spring Boot, you can just add 

@ConfigurationPropertiesScan to your main application class, and it will find all your config beans automatically.

11. What is Spring profile 
Spring Profiles are a way to segregate parts of your application configuration and make it only available in certain environments
1. How it works: The "Two Pillars"
Spring Profiles work by controlling two main things: Properties and Beans. 
A. Profile-Specific Properties
Spring Boot looks for files following the naming convention: application-{profile}.properties (or .yml).
•	application.properties: Common settings for everyone.
•	application-dev.properties: Local 

database, low security, "DEBUG" logging.
•	application-prod.properties: Real database, high security, "ERROR" only logging.
When you activate the prod profile, Spring loads application.properties first, then overwrites those values with anything found in application-prod.properties.

B. Profile-Specific Beans
You can use the @Profile annotation to tell Spring, "Only create this object if a specific profile is active."

@Configuration
@Profile("dev")
public class DevDbConfig {
    @Bean
    public DataSource dataSource() {
        return new 

EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseType.H2).build();
    }
}
In the example above, if the dev profile is NOT active, this entire class is ignored, and the H2 database is never even started.

2. How to Activate a Profile
There are several ways to tell Spring which "skin" to put on:
•	In application.properties: spring.profiles.active=dev
•	Via Command Line (Standard for Production): java -jar myapp.jar --spring.profiles.active=prod
•	Via Environment Variables (Standard for Docker/Kubernetes): export SPRING_PROFILES_ACTIVE=prod
•	In Testing: Use @ActiveProfiles("test") 

at the top of your test class.

3. The "Default" Profile
If you don't specify any profile, Spring uses a profile named default.
•	Any bean without a @Profile tag belongs to default (and runs everywhere).
•	You can create an application-default.properties file for settings that should only apply when no other profile is picked.
Pro Tip: You can activate multiple profiles at once by separating them with commas (e.g., --spring.profiles.active=prod,debug). This allows you to stack configurations
    like building blocks.

12. How to override auto configured beans
1. The Most Common Way: 

Define Your Own @Bean
Spring Boot's auto-configuration classes almost always use the @ConditionalOnMissingBean annotation. This tells Spring: "Only create this default bean if the user 
    hasn't provided their own." 
To override it, simply define a bean of the same type in your @Configuration class.
•	Result: Spring Boot sees your bean, matches the type, and cancels its own auto-configuration for that specific component.

2. The Selective Way: Using Properties
Many auto-configured beans are "property-driven." Before writing code to override a bean, check if you can simply change its behavior via application.properties.
Example: Changing the default Data Source

Instead of creating a DataSource bean manually, you can override the auto-configured one by providing your own settings:  
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=admin
spring.datasource.password=secret

3. The Forceful Way: Explicit Exclusion
Sometimes you don't want to just override a bean; you want to kill the entire auto-configuration class because it's interfering with your custom setup. 
You can exclude specific auto-configuration classes in two ways:

A. Via Annotation (Recommended)
Use the exclude attribute on your main 

application class:
@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})
public class MyProjectApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyProjectApplication.class, args);
    }
}

B. Via Properties
If you don't want to change the code, you can do it in application.properties:
spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration

4. The "Tie-Breaker": @Primary and @Qualifier

If you define a bean but Spring Boot still tries to use its own (or if you have multiple beans of the same type), you can use these annotations:
•	@Primary: Tells Spring, "If there are multiple beans of this type, use this one by default."
•	@Qualifier: Used at the injection point (where you use @Autowired) to name exactly which bean you want.

How to see what to override?
If you aren't sure which bean is being created, you can run your app with the --debug flag:
java -jar app.jar --debug
This will generate a Positive/Negative Matches report in your console. It shows exactly which auto-configurations were applied and why.

13. What is externalized configuration
Externalized Configuration is a core philosophy of Spring Boot that allows you to separate your application's settings (like database URLs, passwords, or API keys)
    from your actual code.
The goal is to write your code once and use "external" files or environment variables to change its behavior as it moves from your local machine to a testing server
    and finally to production.

Why Externalize?
If you "hard-code" a database URL inside your Java code, you have to recompile and rebuild your entire application every time that URL changes. With externalized
    configuration:
•	Security: You don't store passwords in your source code (or GitHub).

•	Portability: The same .jar file can run in any environment.
•	Flexibility: You can change settings at runtime without touching the code.
2. The Order of Precedence (The Hierarchy)
Spring Boot is very flexible about where it looks for configuration. If the same property (e.g., server.port) is defined in multiple places, Spring uses a specific
    Order of Precedence. 
Here are the most common sources, from highest priority (overwrites everything) to lowest:
•	Command Line Arguments: java -jar app.jar --server.port=9090
•	Environment Variables: export SERVER_PORT=9090
•	Profile-specific Properties: application-dev.properties

•	Application Properties: application.properties (inside the jar)
•	Default Properties: Set via SpringApplication.setDefaultProperties.
3. How to Access External Properties
Spring provides two main ways to "pull" these external values into your code:
A. The @Value Annotation
Best for single, simple values.
B. @ConfigurationProperties
Best for grouping related properties into an object (as we discussed earlier). This is the "cleaner" way for production apps.
4. Common External Sources
•	Properties/YAML Files: The standard application.properties or application.yml.
•	OS Environment Variables: Great for 

Docker and Kubernetes (e.g., DB_PASSWORD).
•	Config Servers: In microservices, you can use Spring Cloud Config to store all settings in a central Git repository that your apps fetch at startup.
•	Key Vaults: Secret managers like AWS Secrets Manager or Azure Key Vault.

14. How environment variables work in Spring Boot 

Environment Variables are a powerful way to externalize configuration, especially in modern cloud and containerized environments like Docker and Kubernetes.
1. The Naming Convention (Relaxed Binding)
This is the most important part. While your Java code might look for a property called 

spring.datasource.password, Environment Variables usually follow a SCREAMING_SNAKE_CASE format.
Spring Boot automatically maps them using these rules:
•	Replace dots (.) with underscores (_).
•	Remove hyphens (-).
•	Convert to uppercase.
server.port
SERVER_PORT
spring.datasource.url
SPRING_DATASOURCE_URL
mongodb.connection-string
MONGODB_CONNECTION_STRING

2. How to Set and Use Them
Setting the Variable
Depending on your OS, you set them before running your application:
•	Linux/Mac: export SERVER_PORT=9090 

&& java -jar app.jar
•	Windows (PowerShell): $env:SERVER_PORT=9090; java -jar app.jar
•	Docker: docker run -e SERVER_PORT=9090 my-app-image

Accessing the Variable in Java
You don't need to do anything special to access them. Spring treats them as standard properties:
@Value("${SERVER_PORT}") // Directly using the ENV name
private int port;

// OR (Better Practice)

@Value("${server.port}") // Spring maps the ENV variable to this automatically
private int mappedPort;

3. Why Use Environment Variables?
•	Security: You can pass sensitive data (like DB_PASSWORD) into a container at runtime without ever saving the password in a text file or Git.
•	Cloud Native: Tools like Kubernetes and AWS ECS are designed to inject configuration via environment variables.
•	Overriding: Environment variables have a higher priority than properties inside your application.properties. If you have server.port=8080 in your file but set
    SERVER_PORT=9090 in your environment, the app will run on 9090.
4. Complex Types (Lists and Maps)
You can even pass lists or arrays via 

environment variables using a specific index syntax:
To map to a list in Java:
my.app.list[0]=value1, my.app.list[1]=value2
Use this Environment Variable format:
MY_APP_LIST_0=value1
MY_APP_LIST_1=value2
5. System Properties vs. Environment Variables
It is easy to confuse these two. Here is the quick breakdown:
System Properties
-Dserver.port=9090
Higher (Overrides Env Vars)
Environment Variables
export SERVER_PORT=9090


16. How to disable auto configuration

To disable auto-configuration in Spring Boot, you have three primary routes depending on whether you want to do it via code, configuration files, or by removing
    the "trigger" entirely.
1. Using the @SpringBootApplication Annotation
This is the most common method. If you know the specific auto-configuration class you want to stop, you can exclude it directly in your main class.
@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class, SecurityAutoConfiguration.class})
public class MyMainApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyMainApplication.class, args);

    }
}

•	Best for: Specific, permanent exclusions that should apply regardless of the environment.
2. Using application.properties or yml
If you don't want to change your Java code (or want the ability to toggle it per profile), you can use the property key. 
In application.properties:
spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
3. Selective Disabling (The "Gentle" Way)
Sometimes you don't need to disable the entire auto-configuration; you just want to 

stop one specific part of it.
Define your own Bean: Most auto-configs use @ConditionalOnMissingBean. If you define your own @Bean of that type, the auto-config will back off automatically.

Disable by Property: Some starters provide a "switch." For example, to keep the security libraries but disable the security filters:
spring.security.enabled=false
4. Removing the Dependency
Auto-configuration only triggers if it finds specific classes on your classpath. If you don't want a specific feature (like MongoDB support) and you aren't using it,
    the cleanest way is to simply remove the starter from your pom.xml or build.gradle. 
How to find the name of the class to exclude?

If you are unsure of the exact name of the auto-configuration class (e.g., DataSourceAutoConfiguration), you can:
•	Run with Debug: Run your app with --debug.
•	Check the Report: Look for the "AUTO-CONFIGURATION REPORT" in the console.
•	Positive Matches: Look under this section to see which classes are currently active. Copy the full class name and add it to your exclusion list.
Note: If you are using @EnableAutoConfiguration instead of @SpringBootApplication, the exclude attribute works exactly the same way.

17.  What is Devtools
A. Automatic Restart
DevTools monitors your classpath for changes. As soon as you hit "Save" (or 

"Build") in your IDE, DevTools detects the change and restarts the application automatically. 
•	Why it’s fast: It uses a two-classloader trick. One classloader loads the "Base" classes (libraries that don't change), and another loads "Restart" classes
    (your code). When you save, only the "Restart" classloader is killed and recreated, making it significantly faster than a cold start.

B. LiveReload
DevTools includes an embedded LiveReload server. When combined with a LiveReload browser extension, your browser tab will automatically refresh as soon as you
    change a resource (like an HTML or CSS file). 
C. Property Defaults (Cache 

Disabling)
Some libraries use caching to improve performance (like Thymeleaf templates). While great for production, this is annoying for development because you won't see
    your changes immediately. 
•	DevTools automatically disables these caches so you always see the latest version of your UI.
D. Global Settings
You can configure DevTools globally (across all your projects) by creating a file named .spring-boot-devtools.properties in your $HOME folder.
2. How to Add It
Just add the following dependency to your project. Spring Boot is smart enough to ensure that DevTools is automatically disabled when you package your app as a 
    production JAR.

Maven:
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <optional>true</optional>
</dependency>
3. Remote Development
One of the "hidden" features of DevTools is support for remote applications. You can set it up so that when you save code locally, it pushes those changes to an
    application running on a remote server (like a dev cloud environment) and restarts it there.
4. Key Limitations to Remember
•	Not for Production: DevTools is automatically disabled when running 

java -jar or if the app is started via a custom classloader. You should never include it in a production environment.
•	State Loss: Since it restarts the application context, any data stored in memory (like an in-memory H2 database or a user session) will be lost unless you've
    externalized it.

18. Difference between war and jar deployment
In the Java world, choosing between JAR and WAR is essentially a choice between "bringing your own server" or "renting a space on someone else's server."
With the rise of Spring Boot and cloud-native development, JAR has become the industry standard, but WAR is still heavily used in traditional enterprise environments.

1. JAR (Java Archive) – "The Self-Contained App"
In Spring Boot, a JAR is often called an Executable JAR. It contains everything your application needs to run, including the server itself (embedded Tomcat, Jetty,
    or Undertow). 
•	Packaging: Includes your compiled classes, resources, and all dependency libraries (JARs inside a JAR).
•	The Server: The web server is "embedded." It is just another library inside your project.
•	Deployment: You simply run it using a command: java -jar app.jar.
•	Best for: Microservices, Cloud (AWS, Azure), Docker containers, and modern DevOps pipelines.
2. WAR (Web Archive) – "The 

Guest App"
A WAR file is designed to be deployed onto a Standalone Servlet Container or Application Server (like a separate installation of Tomcat, WildFly, or GlassFish). 
•	Packaging: Follows a strict structure (e.g., WEB-INF/lib, WEB-INF/classes). It does not include the server.
•	The Server: You must install and manage a server separately. You "drop" the WAR file into the server's webapps folder.
•	Deployment: The server detects the file, unpacks it, and starts the application.
•	Best for: Legacy enterprise systems where one big server hosts multiple different applications at once.

20. Difference between @controller @restcontroller

the difference between these two annotations comes down to how the data is sent back to the user: one is designed for Web Pages, while the other is designed for APIs.
Technically, @RestController is a "convenience annotation" that is actually composed of @Controller + @ResponseBody
1. @Controller (The Traditional Way)
The @Controller annotation is used for traditional web applications that return Views (HTML pages).
•	How it works: When a method returns a String, Spring looks for an HTML template (like Thymeleaf or JSP) with 

that name.
•	The Workflow: Request \rightarrow Controller \rightarrow View Resolver \rightarrow HTML Page.

2. @RestController (The Modern API Way)
The @RestController is used for RESTful web services. It assumes every method will return Data (JSON or XML) instead of an HTML page.
•	How it works: It automatically adds @ResponseBody to every method. The object you return is automatically converted into JSON by a library like Jackson.
•	The Workflow: Request \rightarrow Controller \rightarrow Message Converter \rightarrow JSON Data

Can I return JSON from a @Controller?
Yes! If you are using @Controller but have one specific method that needs to return JSON (like an AJAX call), you can add @ResponseBody just to that method:
@Controller
public class MixedController {
    
    @GetMapping("/page")
    public String getPage() { return "index"; } // Returns HTML

    @GetMapping("/api/status")
    @ResponseBody
    public String getStatus() { return "OK"; } // Returns raw string/data
}

21.how to customize the JSON output (like changing date formats) using Jackson annotations?
To customize how Spring Boot (via the Jackson library) handles your Java objects when converting them to JSON, you primarily use annotations on your POJO fields.
Here are the most common ways to tweak your JSON output:
1. Renaming Fields with @JsonProperty
If your Java variable names don't match the naming convention required by the API (e.g., your Java uses camelCase but the API requires snake_case), use this annotation
public class User {
    @JsonProperty("user_id")
    private int id;

    @JsonProperty("full_name")
    private String name;
}
// Output: {"user_id": 1, "full_name": "John Doe"}
2. Formatting Dates with @JsonFormat
By default, Jackson might represent dates as a timestamp (a long number). You can force a specific readable format easily.
public class Event {
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime eventDate;
}
// Output: {"eventDate": "2026-02-06 14:30:00"}

3. Ignoring Fields with 

@JsonIgnore or @JsonIgnoreProperties
Use this for sensitive data (like passwords) or internal flags that should never be sent to the client.
public class User {
    private String username;

    @JsonIgnore
    private String password; // This will be completely omitted from JSON
}

4. Handling Nulls with @JsonInclude
Sometimes you don't want to send a field at all if its value is null, rather than sending "key": null.
@JsonInclude(JsonInclude.Include.NON_NULL)

public class Project {
    private String title;
    private String description; // If null, the key "description" won't appear in the JSON
}

5. Global Customization (The "Spring Way")
If you want all your dates to look the same or all your keys to be snake_case without annotating every single class, you can set global rules in your application.properties:
# Global snake_case strategy
spring.jackson.property-naming-strategy=SNAKE_CASE

# Global date format
spring.jackson.date-format=yyyy-MM-dd HH:mm:ss
spring.jackson.serialization.write-dates-as-

timestamps=false

Change Key Name
@JsonProperty("new_name")
Hide a Field
@JsonIgnore
Format Date
@JsonFormat(pattern = "...")
Hide Nulls
@JsonInclude(Include.NON_NULL)
Order Fields
@JsonPropertyOrder({"id", "name"})


21. Lifecycle of Spring bean
The Stages of the Lifecycle
The lifecycle can be broadly divided into four main phases: Instantiation, Populating Properties, Initialization, and Destruction.
1. Instantiation (The Birth)
The container finds the bean's definition 

(XML or @Component) and creates a new instance of the class. This is essentially calling the constructor.
2. Populate Properties (Dependency Injection)
Once the object exists, Spring "injects" the dependencies. This is when your @Autowired fields or constructor arguments are filled with their respective beans. 
3. Initialization (The Setup)
This is where the bean is "prepared" for use. It involves several sub-steps:
•	Aware Interfaces: If your bean implements interfaces like BeanNameAware or ApplicationContextAware, Spring gives the bean information about its environment.
•	BeanPostProcessors (Before): Special classes that can modify your bean 

before it initializes.
•	The @PostConstruct Method: The bean performs any custom setup logic (e.g., opening a connection).
•	BeanPostProcessors (After): Final modifications before the bean is ready.
4. Ready for Use
The bean is now fully baked and lives inside the Application Context, waiting to be used by your application logic. 
5. Destruction (The Death)
When the application shuts down (the container closes), the bean is cleaned up.
•	The @PreDestroy Method: The bean runs any cleanup logic (e.g., closing a file or database connection).
Summary Table
Instantiation
Bean object is created.
Constructor
Dependency Injection

Dependencies are injected.
@Autowired / Setters
Post-Processing
Environment info provided.
Aware interfaces
Initialization
Final setup logic.
@PostConstruct
In Service
Bean is ready to work.
(The App is running)
Destruction
Cleanup before shutdown.


22. How does @teansactional work internally

In Spring, @Transactional works through a design pattern called AOP (Aspect-Oriented Programming). It essentially uses 

a Proxy—a "middleman" that wraps your class and manages the database connection for you. 
Here is the step-by-step internal flow of what happens when you call a transactional method.
1. The Proxy Creation
When Spring starts up, it scans your beans for the @Transactional annotation. If it finds one, it doesn't just inject your raw class into other beans; it 
    creates a Proxy object (usually using CGLIB or JDK Dynamic Proxies). 
2. The Step-by-Step Internal Flow
When a caller executes your method, the call goes to the Proxy first, not your actual code: 
•	Intercept: The Proxy intercepts the call.
•	Transaction Manager: The Proxy asks the PlatformTransactionManager (like 

DataSourceTransactionManager) to start a new transaction.
•	Connection Binding: The Transaction Manager gets a connection from the Data Source and binds it to the current thread (using ThreadLocal).
•	Target Execution: Only now does the Proxy call your actual method. Every database query inside your method looks for a connection on the current thread
    and finds the one we just opened.
•	The Result: 
•	Success: If your method finishes without an error, the Proxy tells the Transaction Manager to Commit.
•	Failure: If a RuntimeException occurs, the Proxy tells the Transaction Manager to Rollback.
•	Cleanup: The connection is released/closed and unbound from the thread.

3. Important Internal "Gotchas"
A. Self-Invocation (The "Inside Call" Problem)
This is the most common bug with @Transactional. If you call a transactional method from another method inside the same class, the transaction will fail to start. 
•	Why? Because the call is happening directly on this, skipping the Proxy "middleman." To Spring, it looks like a normal method call.
B. Visibility
Internal Spring AOP proxies only work on public methods. If you put @Transactional on a private or protected method, Spring will ignore it without throwing an error. 
C. Rollback Rules
By default, Spring only rolls back for Unchecked Exceptions (RuntimeException and Error). It will not roll back for Checked 

Exceptions (like IOException or SQLException) unless you explicitly tell it to:
@Transactional(rollbackFor = Exception.class)
Summary of Components
Proxy
Intercepts the call and handles the "Before" and "After" logic.
TransactionManager
Decides whether to Open, Commit, or Rollback.
TransactionDefinition
Holds settings like Propagation, Isolation, and Timeout.
TransactionStatus
Represents the state of the current transaction.


23.  Write an immutable API in springboot 

Building an immutable API in Spring Boot is a fantastic way to ensure thread safety, reduce side effects, and make your code significantly easier to debug. 
    In the Java ecosystem, this is primarily achieved using Records (introduced in Java 14/16) and a functional approach to data flow.
Here is a clean implementation of an immutable REST API.
1. The Immutable Model (The Record)
Using a Java record automatically makes the fields private final and generates the constructor, getters, equals, and hashCode methods. Once created, this object
    cannot be changed.
Note on Persistence: If you use Spring Data JPA, entities are technically mutable by design (Hibernate requires a no-args constructor and setters). To keep the API 

truly immutable, map your mutable @Entity objects to immutable Records (DTOs) before returning them to the controller.

24. Explain why constructor injection is preferred

In Spring Boot, Constructor Injection is the gold standard for dependency injection, especially when building robust, production-grade applications. 
    While @Autowired on a field is shorter to write, constructor injection offers structural advantages that field injection simply can't match.
1. Requirement of Final Fields (Immutability)
As we discussed with the immutable API, constructor injection allows you to declare 

your dependencies as final.
•	Field Injection: You cannot use final because the field must be modified by Spring via reflection after the object is instantiated.
•	Constructor Injection: The dependency is assigned at the moment of creation. This ensures the dependency cannot be changed (mutated) or become null during 
    the lifecycle of the bean.

private final ProductService productService; // 'final' is only possible with constructor injection

2. Ease of Unit Testing
This is perhaps the biggest practical advantage. When you use constructor injection, your class has no "hidden" dependencies.

•	No Spring Needed: You can instantiate the class in a plain JUnit test using the new keyword and pass in a Mockito mock.
•	With Field Injection: You are forced to use @SpringBootTest (which is slow) or use reflection utilities to "force" the dependency into the private field.
3. Prevention of NullPointerExceptions
Constructor injection guarantees that a bean is never created in an uninitialized state. If a required dependency is missing, the application will fail to compile
    or fail immediately at startup rather than throwing a NullPointerException at runtime when a specific method is called.
4. Circular Dependency Detection

Spring can detect circular dependencies (Class A needs Class B, and Class B needs Class A) much more effectively with constructor injection. It will throw a
    BeanCurrentlyInCreationException at startup, forcing you to fix a flawed architectural design early.
Comparison at a Glance
Immutability
Supported (final fields)
Not supported
Testability
Easy (POJO-friendly)
Hard (Requires Spring context)
Transparency
Explicit (Visible in signature)
Hidden (Magic reflection)
Safety
Fail-fast at startup
Potential NPE at runtime

Pro-Tip: Use Lombok to save space
If you find constructors too verbose, you can use the @RequiredArgsConstructor annotation from Lombok. It will automatically generate the constructor for all
    final fields, keeping your code clean while maintaining all the benefits of constructor injection.

@RestController
@RequiredArgsConstructor // Automatically creates the constructor for you
public class ProductController {
    private final ProductService productService;
}

25. How does springboot handles Circular 

Dependency

a perfect architectural world, circular dependencies (where Bean A requires Bean B, and Bean B requires Bean A) shouldn't exist. However, legacy code or 
    complex logic sometimes makes them inevitable.
Spring Boot handles these differently depending on the Injection Method used and the Version of Spring Boot you are running. 
1. How Spring Detects it (The "Chicken and Egg" Problem)
Spring manages beans in a "Context." During startup, it tries to instantiate everything in order. 
•	With Constructor Injection: Spring is stuck. It cannot create Bean A because it needs Bean B for the constructor. It cannot create Bean B because it needs 

Bean A for its constructor.
•	The Result: Spring throws a BeanCurrentlyInCreationException and the application fails to start.
2. Default Behavior (Spring Boot 2.6+)
Starting with Spring Boot 2.6, circular dependencies are forbidden by default. If the framework detects one, the application will crash immediately upon startup.
    This was a deliberate move by the Spring team to encourage better software design. 
If you must allow it (not recommended), you have to explicitly enable it in your application.properties:

spring.main.allow-circular-references=true

3. How to Resolve Circular 

Dependencies
If you encounter this error, here are the three primary ways to fix it, ordered from "Quick Fix" to "Best Practice."
A. The @Lazy Hint (The "Wait a Minute" Approach)
By placing @Lazy on one of the dependencies, Spring won't fully initialize that bean until it’s actually needed for a method call. Instead, it injects a proxy.

@Service
public class ServiceA {
    private final ServiceB serviceB;

    public ServiceA(@Lazy ServiceB serviceB) { // Injects a proxy initially
        this.serviceB = serviceB;
    }
}


B. Setter/Field Injection (The "Post-Construction" Approach)
While we discussed why constructor injection is better, Setter Injection technically "solves" the circle. Spring creates the objects using their no-args 
    constructors first, and then "wires" the dependencies into them afterward. This breaks the deadlock during the instantiation phase.
C. Architectural Refactoring (The "Right" Way)
Usually, a circular dependency is a sign that your classes are doing too much.
•	Extract a Third Class: Take the common logic that both ServiceA and ServiceB need and move it to ServiceC.
•	Use Events: Instead of ServiceA calling ServiceB directly, have ServiceA publish 

an application event that ServiceB listens for.


26. How is @data from lombok is different from record class
While both @Data and record aim to reduce boilerplate in Java, they represent fundamentally different philosophies: @Data is about convenience for mutable objects,
    while record is about strict data integrity through immutability.
Here is the breakdown of how they differ:
1. Mutability vs. Immutability
This is the most significant architectural difference.
•	Lombok @Data: Generates getters, setters, and a non-final constructor. By default, the resulting class is mutable—you can change the values of the fields 

after the object is created.
•	Java record: All fields are implicitly private final. There are no setters. Once you instantiate a record, its state is locked forever.
2. Structural differences
Standard class
Specialized "Record" type
Inheritance
Can extend other classes
Cannot extend classes (final)
Fields
Can add instance fields anytime
Fields must be defined in the header
Boilerplate
Handled by annotation processor
Handled by the Java Compiler
Getters
getName()
name()

4. When to use which?
Use @Data when:
•	You are using JPA/Hibernate entities. Hibernate requires a no-args constructor and setters to "proxy" entities, which records don't provide.
•	You need to extend a base class or allow other classes to extend yours.
•	You are working on a legacy codebase (pre-Java 14).
Use record when:
•	You are creating DTOs (Data Transfer Objects) for APIs.
•	You want to ensure thread safety by preventing state changes.
•	You are building "Value Objects" where the data is the identity.
•	You want the cleanest, most modern Java syntax available.
The Hybrid Approach: If you want the 

benefits of Lombok but need immutability like a record, you can use @Value instead of @Data. It makes all fields private final and removes setters, essentially 
acting as a "manual" record for older Java versions or complex class hierarchies.

27. Where not to use records
1. JPA / Hibernate Entities
This is the most common pitfall. JPA (Java Persistence API) and records are fundamentally incompatible for several reasons:
•	No-Args Constructor: Hibernate requires a protected or public no-arguments constructor to instantiate the object before filling it with database data. 
Records do not have one.
•	Proxying: Hibernate uses "Lazy Loading" by creating proxies 

(subclasses) of your entities. Since records are final, they cannot be subclassed.
•	Mutability: Hibernate tracks changes to entities via setters. Without them, the "dirty checking" mechanism breaks.
The Fix: Use a standard class with Lombok's @Data or @Getter/@Setter for Entities, and use Records for the DTOs (Data Transfer Objects) you send over the wire.

2. When Inheritance is Required
Records cannot participate in traditional class hierarchies:
•	No Extending: A record cannot extend another class.
•	Final by Design: Other classes cannot extend a record.

•	Interfaces only: They can implement interfaces, but if your architecture relies on an abstract class for shared logic, a record won't work.
3. Objects with "Circular" Relationships
In a mutable world, you can link two objects easily: parent.setChild(child) and child.setParent(parent).
In the record world, you must provide all data at the moment of construction. Since Parent needs Child and Child needs Parent to be created, you end up in 
    a "chicken and egg" deadlock that is nearly impossible to resolve with pure records.
4. Large Objects Needing "Partial" Updates
If you have a record with 30 fields and you only want to change the email field, you 

have to create a brand-new instance copying the other 29 fields manually.
While you can write "wither" methods (e.g., user.withEmail("new@me.com")), this becomes incredibly verbose and memory-heavy if you are performing frequent,
    small updates to massive objects.
5. Encapsulation of Internal State
Records are "transparent carriers." Every field in a record is automatically public via its accessor (e.g., user.password()).
If you need to hide internal state, perform complex logic inside a getter, or maintain a "private" field that isn't part of the object's identity, a standard 
    Class is the only way to go.
Summary Checklist
API Request/Response
✅ Yes

Perfect for immutable DTOs.
Database Entity
❌ No
Hibernate needs setters/proxies.
Thread-Safe Data
✅ Yes
Natural immutability.
Complex Logic/State
❌ No
Records shouldn't have "hidden" state.
Small Value Objects
✅ Yes
Great for coordinates, money, etc.

29. how to implement the "Wither Pattern" to update records without losing the benefits of immutability?

Since you can't use setters in a record, you use the Wither Pattern. Instead of modifying the existing object, you create a 

"copy constructor" or a method that returns a brand-new instance with one value changed.
1. Manual Wither Methods
You define a method that follows the naming convention withFieldName.
public record User(Long id, String name, String email) {
    
    // Create a new User instance with only the email changed
    public User withEmail(String newEmail) {
        return new User(this.id, this.name, newEmail);
    }
    
    public User withName(String newName) {
        return new User(this.id, newName, this.email);
    }

}

Usage in a Service:
User user = new User(1L, "Alice", "alice@example.com");

// "Update" the user
User updatedUser = user.withEmail("alice.new@gmail.com");

System.out.println(user.email());        // alice@example.com (Original unchanged)
System.out.println(updatedUser.email()); // alice.new@gmail.com (New instance)

2. Using Lombok's @With
If your record has many fields, writing these methods manually is tedious. You can use Lombok to generate them for you
import lombok.With;


@With // Generates wither methods for all fields
public record Product(String id, String name, double price, String category) {}

This allows you to do:
Product discounted = myProduct.withPrice(19.99);
3. Why this is better for Concurrency
In a multi-threaded Spring Boot application, if Thread A is reading an object while Thread B is "updating" it:
•	With Setters: Thread A might read a "half-updated" state (e.g., the new name but the old email), leading to data inconsistency.
•	With Records/Withers: Thread A keeps its reference to the old, complete 

object. Thread B creates an entirely new object. There is zero chance of a "dirty read."
4. Performance Reality Check
You might wonder: "Isn't creating new objects every time slow?"
In modern JVMs, creating short-lived objects is incredibly cheap. The Garbage Collector (especially G1 or ZGC) is optimized for "young generation" objects. 
    The safety and clarity gained from immutability almost always outweigh the negligible memory overhead of creating a few extra DTOs.


28. different logging slf4j etc in springboot and their differences
1. SLF4J (The Facade)SLF4J (Simple Logging Facade for Java) is not a logging framework; it is an abstraction layer.
    Why it’s used: It allows you to write logger.info("...") in your code while remaining agnostic about whether you're using Logback, Log4j2, or JUL.
    Key Feature: Placeholder Support. Instead of string concatenation ("Value is " + val), you use {}. This is faster because if the log level (e.g., DEBUG) is disabled,
        the string construction never happens.You use Lombok's @Slf4j annotation to automatically inject the log variable into your classes, reducing boilerplate.

2. The Implementations Spring Boot provides support for three main implementations out of the box:
    Logback (The Default)
        Status: The default engine for spring-boot-starter-logging.
        Pros: Faster and smaller footprint than the original Log4j. It supports "Automatic Reloading" of configuration files and is natively designed to work with SLF4J.
        Config File: logback-spring.xml.Log4j2 
3.  The Performance Leader)
        Status: A popular alternative, often used in high-throughput enterprise systems.
        Pros: Offers Asynchronous Loggers, which use a "LMAX Disruptor" library to handle logging in a separate thread. This can be significantly faster than Logback 
            in multi-threaded environments.
        Config File: log4j2-spring.xml.JUL (Java Util Logging)Status: The built-in Java logging.Pros: No external dependencies.Cons: Very limited features compared to
            Logback/Log4j2. Rarely used in Spring Boot microservices.

Comparison Table
Feature                SLF4J                  Logback               Log4j2    
Role                   Facade(Interface)      Implementation        Implementation
SpringBoot Default     Yes                    Yes                   No (Must exclude Logback)
Asynchronous Logging   N/A                    Supported             Superior Performance
Configuration          None(Code only)        XML/Groovy            XML/JSON/YAML
Modern Features        Placeholders {}        Auto-reload config    Lambda support, Garbage-free

If your IoT project required extreme performance, you might have switched from Logback to Log4j2.
In Spring Boot, you do this by excluding the default logging starter in your pom.xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter</artifactId>
    <exclusions>
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-logging</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-log4j2</artifactId>
</dependency>
