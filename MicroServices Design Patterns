
Microservices Design patterns 
-----------------------Integration Patterns------------------

1. API Gateway Pattern (Used in GAP project)        GED : short for Gateway Enable Discovery Client
         The API Gateway acts as a single entry point that aggregates and routes requests to the relevant microservices while handling common concerns.
         In microservices, clients may need to communicate with multiple services (e.g., User, Order, Product). Exposing all services directly means:
             Clients must know the location details of every microservice.
            Repeated Effort: Concerns like authentication, rate-limiting, and logging are repeated in every service.
Authentication and Authorization: Implement filters in the gateway to handle user authentication and authorization checks before forwarding requests to backend services. 
Load Balancing: Configure the gateway to load balance requests across multiple instances of a backend service. 
Caching: Cache frequently accessed data at the gateway level to improve performance. 
Error Handling: Implement error handling mechanisms in the gateway to gracefully handle errors from backend services and provide appropriate responses to the client. 

Key points about the API Gateway pattern:
         Single Entry Point: Clients interact with only one endpoint (the gateway) to access various backend services. 
         Flexibility: The gateway can be used to implement custom logic for different clients or API versions. 
   
Example: Spring Cloud Gateway.

   pom.xml
       <artifactId>spring-cloud-starter-gateway</artifactId>
      <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>

main.java      
   @SpringBootApplication
   @EnableDiscoveryClient     // Enables the gateway to discover available microservices through a service registry like Eureka
   public class ApiGatewayApplication {
      public static void main(String[] args) {
        SpringApplication.run(ApiGatewayApplication.class, args);
      }
    }


application.yml
server:
  port: 8080

spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://USER-SERVICE
          predicates:
            - Path=/users/**
        - id: order-service
          uri: lb://ORDER-SERVICE
          predicates:
            - Path=/orders/**
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/




NOTE: Rate limiting -  is a mechanism that controls the number of requests an API can handle within a given time period.
         It's used to protect the system from overload, ensure that APIs perform well and provide a good user experience. 
         How it works: Rate limits are calculated in requests per second (RPS). 
                       If a client exceeds the rate limit, the server may respond with an error message, say no to the request, or delay its response. 
         Benefit:  It can protect against malicious activity and improve the security posture of a company.

                  Rate limiting helps ensure that resources are available to all users.

How to implement rate limiting in Spring Boot:
Spring Cloud Gateway:
Use the built-in "Rate Limiting Filter" in Spring Cloud Gateway, which integrates with Redis to manage rate limits. 

 -------------Cross-Cutting Concern Patterns----------------
2. Externalized Configuration (Used in GAP project)
Problem : A service typically calls other services and databases as well. For each environment like dev, QA, UAT, and/or prod, the endpoint URL or other configuration
         properties might be different. A change in any of those properties might require a re-build as well as re-deploy of the service. How do we avoid code 
         modification for configuration changes?
Solution : Externalized configuration, including endpoint URLs and credentials, will mitigate the problem. The application should load them either at startup or
         on the fly. The Spring Cloud config server provides the option to externalize the properties to GitHub and load them as environment properties. 
         These can be accessed by the application on startup or can be refreshed without a server restart.
         
         Spring Boot supports various external sources for these configurations, such as:
                  Properties files (.properties)
                  YAML files (.yml)
                  Environment variables
                  Command-line arguments

         // if the configuration is stored in github, the following file must be used.
         bootstrap.properties
                  spring.cloud.config.name = application name
                  spring.cloud.config.uri = ${SPRING_CLOUD_CONFIG_URI)}
                  spring.cloud.config.failFast = true

                  spring.cloud.config.failfast = false
                  spring.config.activate.on-profile = default, local


         chartis-dev.properties   or chartis-stage.properties or chartis-prod.properties      // for diff environments
                  version = 
                  appName = application name
                  team = teamname 
                  environment = environment name
                  environmentVariables.SPRING_CLOUD_CONFIG_URI = "url of the config file in github"
                  environmentVariables.SPRING_PROFILES_ACTIVE = "stage"
                               

3. Service Registry and Discovery Pattern (Used in GAP project)  
Problem : When microservices come into the picture, we need to address a few issues in terms of calling services:
         With container technology, IP addresses are dynamically allocated to the service instances. Every time the address changes, a consumer service can break 
         and require manual changes. Each service URL has to be remembered by the consumer and become tightly coupled. So how does the consumer or router know all 
         the available service instances and locations?
Solution : A service registry needs to be created, which will log the metadata of each producer service. A service instance should register to the registry when 
         starting and should de-register when shutting down. Therefore, the consumer or router should query the registry and find out the location of the service. 
         The registry also needs to conduct a health check of the producer service to ensure that only working instances of the services are available and able to 
         be consumed through it. 
         There are two types of service discovery:
         1. client-side. example: Netflix Eureka.
         2. server-side. example: AWS ALB


example: Eureka Server

  pom.xml
    <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
    </dependency>


  EurekaServerApplication.java
              @SpringBootApplication
              @EnableEurekaServer
              public class EurekaServerApplication {
                  public static void main(String[] args) {
                  SpringApplication.run(EurekaServerApplication.class, args);
                }
              }


  application.yml
    server:
      port: 8761

    eureka:
      client:
        register-with-eureka: false
        fetch-registry: false


Registering Services
Add the following dependency to both User and Order services:
          <dependency>
              <groupId>org.springframework.cloud</groupId>
              <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
          </dependency>



application.yml
        eureka:
          client:
            service-url:
              defaultZone: http://localhost:8761/eureka/



4. Circuit Breakers (Used in GAP project)    CBR     Circuit Breaker Resilience4j

Problem : A service generally calls other services to retrieve data, and there is a chance that the downstream service may be down. There are two problems with this:
         first, the request will keep going to the down service, exhausting network resources and slowing performance.
         Second, the user experience will be poor and unpredictable. How do we avoid cascading service failures and handle failures gracefully?
Solution : When the number of consecutive failures crosses a threshold, the circuit breaker trips To prevent cascading failures when one service becomes unresponsive.
           and for the duration of a timeout period, all attempts to invoke the remote service will fail immediately. After the timeout expires, the circuit breaker 
           allows a limited number of test requests to pass through. If those requests succeed, the circuit breaker resumes normal operation. Otherwise, if there 
           is a failure, the timeout period begins again.
    example : Resilience4j, Netflix Hystrix.         


pom.xml
    <dependency>
      <groupId>io.github.resilience4j</groupId>
      <artifactId>resilience4j-spring-boot2</artifactId>
      <version>1.7.1</version>
    </dependency>


OrderService.java
@Service
public class OrderService {
    @Autowired
    private RestTemplate restTemplate;

    @CircuitBreaker(name = "userService", fallbackMethod = "userServiceFallback")
    public String getUserData() {
        return restTemplate.getForObject("http://localhost:8081/users", String.class);
    }

    public String userServiceFallback(Exception e) {
        return "User Service is currently unavailable. Please try again later.";
    }
}


application.yml
  resilience4j:
    circuitbreaker:
      configs:
        default:
          failure-rate-threshold: 50
          wait-duration-in-open-state: 5000ms
      instances:
        userService:
          base-config: default



----------------------------Database Patterns------------------------------
5. Database per Service Pattern  (Used in GAP project)
Why Separate Databases?
         Microservices are loosely coupled, and sharing a database violates that principle. Different services have different data storage requirements.
Solution: One database per microservice must be designed. It must be private to that service only, and it should be accessed by the microservice API only.
         It cannot be accessed by other services directly. It helps to address below concerns like
         Scalability (services can scale independently).
         Failure isolation (issues in one database don’t affect others).
         Some business transactions need to query data that is owned by multiple services.

6. Command Query Responsibility Segregation (CQRS)
         Once we implement database-per-service, there is a requirement to query, which requires joint data from multiple services — it's not possible.
Solution: CQRS suggests splitting the application into two parts — the command side and the query side. The command side handles the Create, Update, and Delete requests.
          The query side handles the query component by using materialized views. The event sourcing design pattern is generally used along with it to create events for
          any data change. As such, materialized views are kept up to date by subscribing to the stream of events.

7. Saga Pattern
Problem : When each service has its own database and a business transaction spans multiple services, how do we ensure data consistency across services? 
         For example, for an e-commerce application where customers have a credit limit, the application must ensure that a new order will not exceed the customer’s
         credit limit. Since Orders and Customers are in different databases, the application cannot simply use a local ACID transaction.
Solution : A Saga represents a high-level business process that consists of several sub-requests, which each update data within a single service. 
         Each request has a compensating request that is executed when the request fails. It can be implemented in two ways:
         1. Choreography – When there is no central coordination, each service produces and listens to another service’s events and decides if an action should be
                           taken or not.
         2. Orchestration – An orchestrator (object) takes responsibility for a saga’s decision-making and sequencing business logic.


8.  Event-Driven Pattern (Used in GAP project)
Why Use Event-Driven Architecture?
Decouples services by using asynchronous communication.
Services do not directly call each other; instead, they publish or subscribe to events using a message broker (e.g., RabbitMQ, Kafka).
Improves system resilience and scalability.

CustomClassRabbitMQConfiguration.java

@Configuration
@EnableRabbit
public class CustomClassRabbitMQConfiguration {
         private final ConnectionFactory cnf;
         private final RabbitMqConfigurationBuilder rcb;
         private final ConfigurableBeanFactory cbf;

// constructor

@Value("${rabbitListener.concurrentConsumes.maxValue}")
private int maxConcurrentConsumers;

@Value("${rabbitListener.concurrentConsumes.minValue}")
private int minConcurrentConsumers;

@Bean
public SimpleRabbitListenerContainerFactory customClassRabbitListenerContainerFactory(){
         return rcb.buildConnectionFactory(cnf, maxConcurrentConsumers, minConcurrentConsumers);
}


MessageListenerService.java 
@RabbitListener(queues = {"queue names"}, containerFactory = "customClassRabbitListenerContainerFactory")
@Trace(dispatcher = true)
public void consume(Message<customClassMessage> message) {

}


application-deafult.properties
         spring.rabbitmq.host =  host name here
         spring.rabbitmq.username = 
         spring.rabbitmq.password = 
         spring.rabbitmq.port = 5672
         spring.rabbitmq.virtual-host = development 

         spring.rabbitListener.concurrentConsumers.maxValue = 1
         spring.rabbitListener.concurrentConsumers.minValue = 1
         

------------------Observability Patterns --------------------------
9. Log Aggregation  (Used in GAP project)
   Problem: Consider a use case where an application consists of multiple service instances that are running on multiple machines. Requests often span multiple
         service instances. Each service instance generates a log file in a standardized format. How can we understand the application behavior through logs for a 
         particular request?
   Solution : We need a centralized logging service that aggregates logs from each service instance. Users can search and analyze the logs. They can configure alerts
              that are triggered when certain messages appear in the logs. For example, PCF does have Loggeregator, which collects logs from each component
              (router, controller, diego, etc...) of the PCF platform along with applications. AWS Cloud Watch also does the same.


10. Performance Metrics   (Used in GAP project)
         Problem: When the service portfolio increases due to microservice architecture, it becomes critical to keep a watch on the transactions so that patterns can
                  be monitored and alerts sent when an issue happens. How should we collect metrics to monitor application perfomance?
         Solution: A metrics service is required to gather statistics about individual operations. It should aggregate the metrics of an application service,
                  which provides reporting and alerting. There are two models for aggregating metrics:
         
         Push – The service pushes metrics to the metrics service, e.g., New Relic, AppDynamics, etc.
         Pull – The metrics services pulls metrics from the service, e.g., Prometheus.

11. Health Check  (Used in GAP project)
Problem : When a microservices architecture is implemented, there is a chance that a service might be up yet not able to handle transactions. In that case,
         how do you ensure a request doesn't go to those failed instances? We can address this via a load balancing pattern implementation.
Solution : Each service needs to have an endpoint that can be used to check the health of the application, such as /health. This API should check the status of
         the host, the connection to other services/infrastructure, and any specific logic.

         Spring Boot Actuator does implement a /health endpoint and the implementation can be customized.


