A. what is bean in springboot
A bean is an object managed by the Spring IoC (Inversion of Control) container. The container controls when the bean is created, how its dependencies are injected, and 
when it’s destroyed. For example
a Service doesn't need to know how to create a repository class; it simply asks Spring to inject it as a Bean. This makes our code easier to test and maintain

How to Define a Bean
  There are three primary ways to define a bean in Spring Boot:
   1. Stereotype Annotations: Mark a class with @Component, @Service, @Repository, or @Controller. Spring will scan these and create beans automatically.
   2. Java Configuration: Use @Bean on a method inside a @Configuration class. This is useful for third-party libraries (like your KafkaTemplate) where you can't
      modify the source code to add @Component.
  3. XML Configuration: (Legacy) Defining beans in an applicationContext.xml file.

The Bean Lifecycle
   1. Instantiation: Spring calls the constructor to create the object. The object exists, but dependencies aren’t injected yet.
   2. Dependency Injection: Spring performs Dependency Injection (e.g., injecting the UserRepository into your UserService).
   3. Aware Interfaces: If the bean implements interfaces like BeanNameAware, Spring gives it its metadata.
   4. Initialization: Spring calls methods annotated with @PostConstruct or any custom init() method.
   5. Ready for Use: The bean is now available for your application logic.
   6. Destruction: When the container shuts down, Spring calls methods annotated with @PreDestroy to clean up resources (like closing database connections).

Bean Scopes
  The "Scope" defines how many instances of a bean are created:
   1. Singleton (Default): Only one instance per Spring container. Most services and repositories are Singletons.
   2. Prototype: A new instance is created every time it is requested from the container.
   3. Web Scopes: Request (one per HTTP request), Session (one per HTTP session), and Application

B. The three main types of dependency injection in Spring Boot are:
Dependency Injection (DI) it allows us to achieve the principle of Inversion Of Control (IoC) i.e. shifting the creation, management and the lifecycle of objects from
        the programmer to the framework. This approach helps relieve the programmer from the responsibility of managing and creating objects and allows them to 
        focus mainly on the business logic.

1. Constructor injection : The injector supplies the dependency through the client class constructor. This is the most recommended technique in the Spring Framework. 

public class RESTController {
    private final SmartPhone mySmartPhone;

    //* Constructor Injection  *//
    @Autowired
    public RESTController(SmartPhone theSmartPhone)
    {
        this.mySmartPhone = theSmartPhone;
    }

    @GetMapping("/smartphone/name")
    public String getSmartPhoneName()
    {
        return mySmartPhone.getName();
}
}

2. Setter injection : The injector method injects the dependency to the setter method exposed by the client. This technique provides flexibility for changes at runtime. 

public class RESTController {
    private SmartPhone mySmartPhone;

    //* Setter Injection *//
    @Autowired
    public void setSmartPhone(SmartPhone theSmartPhone) {
        this.mySmartPhone = theSmartPhone;
    }

    @GetMapping("/smartphone/name")
    public String getSmartPhoneName() {
        return mySmartPhone.getSmartPhoneName();
    }
}



3. Field injection: The injector directly injects dependencies into class fields. This is a concise but potentially less flexible approach


C. What is Spring Boot, and how is it different from the Spring Framework?**  (Actuator Starter Tomcat AutoConfig Profiles)
   - Spring Boot simplifies Spring development by embedded server like Tomcat, Jetty, and Undertow.
   - Simplified dependency management with `starter` dependencies. 
   - Actuator gives Production-ready features like metrics, health checks and application monitoring.  Common endpoints:  /actuator/health   and   /actuator/metrics  
   - Reduced boilerplate with annotations and auto-configuration. 
   - features like profiles and externalized configuration
   - Spring Boot provides default loggings. 


D. What is the role of the `@SpringBootApplication` annotation?**  
   - It's a combination of:  
     1. `@Configuration`: class can be used by the Spring IoC container as a source of bean definitions. Classes annotated with @Configuration can define one or more 
                          @Bean methods.
     2. `@EnableAutoConfiguration`: automatically configures Spring beans based on the dependencies/libraries present on the classpath.
              For example, When you include the Spring Web dependency, Spring Boot automatically configures the necessary components for building a web application, 
              including:
                               DispatcherServlet
                               Default error handling
                               View resolvers
                               Static resource handling
                           When you include a database dependency (like H2, MySQL, or PostgreSQL) in your Spring Boot application, Spring Boot automatically configures
                           a DataSource bean.
                           When you include the Spring Security dependency, Spring Boot automatically configures basic security settings
     3. `@ComponentScan`: This annotation tells Spring to scan the specified package(s) for components, configurations, and services. It enables automatic detection of
                          Spring-managed components.
              By default, @ComponentScan scans the package of the class that declares it. You can specify additional packages to scan using the basePackages attribute.

F. How does Spring Boot manage dependencies? 
   - It uses a parent POM (`spring-boot-starter-parent`) that defines dependency versions to ensure compatibility.  
   - You can override versions by specifying them in your `pom.xml` or `build.gradle`.  

G. What are Spring Boot starters? Name a few commonly used starters. 
    Starters are pre-defined dependency packages that help you to quickly define dependencies for your projects and simplify dependency management.
   - Examples:  JPA, Actuator,  Web, Security, DevTools.
     - `spring-boot-starter-web`: For building web applications.  
     - `spring-boot-starter-data-jpa`: For JPA-based data access.  Spring Data JPA provides a repository abstraction over JPA.  
                                       The `JpaRepository` interface provides pre-defined methods for CRUD operations, so you don't have to write SQL.
     - `spring-boot-starter-security`: For security configurations. 
     - 'spring-boot-starter-devTools : to make application changes without restarting the server manually.


H.  How do you secure sensitive configuration data?**  
    - Use environment variables.  
    - External configuration tools like Spring Cloud Config or HashiCorp Vault.  
    - Use Jasypt for encrypting properties.  

I.  
J. How do you handle transactions in Spring Boot?
     The @Transactional annotation is used to define the scope of a single database transaction. It simplifies transaction management, allowing developers to focus
     on business logic while ensuring data integrity and consistency in database operations. The @Transactional annotation works best on public methods. 

      Features of @Transactional
      1. Transaction Management: When a method annotated with @Transactional is called, Spring will start a new transaction. If the method completes successfully,
                                 the transaction will be committed. If an exception occurs, the transaction will be rolled back, ensuring that the database remains
                                 in a consistent state.
      2. Propagation: It supports different propagation behaviors, which determine how transactions are handled when a method is called within another transactional
                      context. The default propagation level is Propagation.REQUIRED, which means that if a transaction already exists, the method will join that
                      transaction; otherwise, a new transaction will be created.
      3. Isolation Levels: You can specify the isolation level of the transaction, which controls how transaction integrity is visible to other transactions. 
                           Common isolation levels include READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, and SERIALIZABLE.
      4. Rollback Rules: By default, Spring will roll back the transaction for unchecked exceptions (subclasses of RuntimeException) and errors. 
                         You can customize this behavior using the rollbackFor and noRollbackFor attributes.
      5. Timeout: You can specify a timeout for the transaction, after which it will be rolled back if it has not completed.
      6. Read-Only Transactions: You can mark a transaction as read-only, which can help optimize performance for operations that do not modify the database.

      Example : use the @Transactional annotation in a Spring service class

            @Service
            public class UserService {

              @Autowired
              private UserRepository userRepository;

              @Transactional
              public User createUser (User user) {
                   // This method will be executed within a transaction
                   return userRepository.save(user);
              }

              @Transactional(readOnly = true)
              public User getUser (Long id) {
                  // This method is marked as read-only
                  return userRepository.findById(id).orElse(null);
              }
           }



K. How do you optimize a Spring Boot application for performance? 
      performance J E A.     J for JPA, E For Enables caching, A for Actuator 
      - Enable lazy loading in JPA.  
      - Use `@EnableCaching` with cache providers like EhCache or Redis.  
      - Use profiling tools like Spring Boot Actuator or Micrometer to identify bottlenecks.  

L. How do you handle database connection pooling in Spring Boot? 
   a database connection pool(HikariCP) is a mechanism that manages a pool of database connections, allowing applications to reuse existing connections rather than
   creating a new one for every database operation. This improves performance and resource management, especially in applications that require frequent database access.

   Key Concepts of Database Connection Pools
    1. Connection Pooling: Instead of opening and closing a database connection for each request, a connection pool maintains a set of active connections. 
       When an application needs a connection, it can borrow one from the pool, and when it's done, it returns it to the pool for reuse.

    2. Performance: Connection pooling reduces the overhead of establishing a new connection each time a database operation is performed. This is particularly beneficial
       in high-load scenarios where many requests are made to the database.

    3. Resource Management: By limiting the number of active connections, connection pools help manage database resources effectively, preventing issues like 
       connection exhaustion.

       Spring Boot uses HikariCP as the default connection pool. Customize the pool in application.properties:  
       spring.datasource.hikari.maximum-pool-size=10
       spring.datasource.hikari.minimum-idle=2

M. 
N. How do you secure a Spring Boot application?**  
    - Use Spring Security with `@EnableWebSecurity`.  
    - Define roles and permissions.  
    - Example:  
      Demo.java
      @Configuration
      @EnableWebSecurity
      public class SecurityConfig extends WebSecurityConfigurerAdapter {
          @Override
          protected void configure(HttpSecurity http) throws Exception {
              http.csrf().disable()                                           HCD AAP AAAF
                  .authorizeRequests()
                  .antMatchers("/public").permitAll()
                  .anyRequest().authenticated()
                  .and()
                  .formLogin();
          }
      }
        

O. What is a custom health indicator in Spring Boot Actuator?**  
    - Implement a custom health check by extending `AbstractHealthIndicator`.  
    - Example:  
      java
      @Component
      public class CustomHealthIndicator extends AbstractHealthIndicator {
          @Override
          protected void doHealthCheck(Health.Builder builder) throws Exception {
              builder.up().withDetail("customCheck", "All systems operational");
          }
      }
       

P. How do you integrate Spring Boot with Kafka or RabbitMQ?**  
    - Use Spring Kafka or Spring AMQP (for RabbitMQ).  
    - Define consumers and producers using configuration beans or annotations like `@KafkaListener` and `@RabbitListener`.  


21. Lazy loading in Spring Boot is a technique that delays the creation of beans until they are requested. This saves system resources and optimize performance. 
    How it works: When the Spring container starts up, it doesn't create all beans immediately Instead, it waits until the bean is needed in the application context 
    Benefits : 
       Startup time: Lazy loading can significantly improve application startup time 
       Memory consumption:  Lazy loading can improve memory consumption, especially when there are a large number of beans.
       Resource consumption:  Lazy loading can reduce resource consumption, which can lead to lower operational costs. 
       How to configure lazy loading : use the @Lazy annotation to configure lazy loading for a class


22. What is lazy loading in JPA?
   In Java Persistence API (JPA), lazy loading is a design pattern used to optimize performance and resource consumption when dealing with entity relationships.
   When you define relationships between entities (like a Person entity and an Address entity), JPA allows you to specify how these relationships should be loaded.
   By default, JPA uses lazy loading which means that related entities are not loaded from the database until they are explicitly accessed.

   example:
           @Entity
           public class Person {
              
           @Id
           private Long id;
           private String name;

           @OneToOne(fetch = FetchType.LAZY)
           private Address address;

           // Getters and setters
          }

          
          @Entity
          public class Address {
          
          @Id
          private Long id;
          private String street;
          private String city;

          // Getters and setters
       }


23. What is fail-fast and fail-safe in Spring Boot?
    Fail-safe iterators will not throw any exception even if the collection is modified while iterating over it. Whereas Fail-fast iterators throw
    an exception( ConcurrentModificationException ) if the collection is modified while iterating over it.


24.  @RestControllerAdvice is a Spring Framework annotation used for global exception handling. It defines a class that is called when an exception occurs,
     which handles exceptions across an entire application. 
     It contains multiple methods with the @ExceptionHandler annotation which returns a ResponseEntity object.

     Benefits : Centralized exception handling makes code more maintainable and readable. It provides a consistent response to users.

example: 

UserNotFoundException.java

public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(String message) {
        super(message);
    }
}


GlobalExceptionHandler.java

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity<Map<String, Object>> handleUserNotFoundException(UserNotFoundException ex) {
        Map<String, Object> response = new HashMap<>();
        response.put("timestamp", LocalDateTime.now());
        response.put("status", HttpStatus.NOT_FOUND.value());
        response.put("error", "Not Found");
        response.put("message", ex.getMessage());                  MEST(Message, Error, Status, Timestamp)

        return new ResponseEntity<>(response, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Map<String, Object>> handleGenericException(Exception ex) {
        Map<String, Object> response = new HashMap<>();
        response.put("timestamp", LocalDateTime.now());
        response.put("status", HttpStatus.INTERNAL_SERVER_ERROR.value());
        response.put("error", "Internal Server Error");
        response.put("message", ex.getMessage());

        return new ResponseEntity<>(response, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}



25. Different stereotype annotations
 1. Component

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Indexed
public @interface Component {
    String value() default "";
}



2. Controller

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Controller {
    @AliasFor(
        annotation = Component.class
    )
    String value() default "";
}


3. Repository
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Repository {
    @AliasFor(
        annotation = Component.class
    )
    String value() default "";
}


4. Service
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Service {
    @AliasFor(
        annotation = Component.class
    )
    String value() default "";
}


26. how does @Autowired simplify dependency injection
    @Autowired as the bridge between your class and the Spring ApplicationContext. Without it, you would have to manually "wire" your objects together using the new keyword
    or complex XML configurations, which leads to tightly coupled code that is difficult to test. 
    
    How it works "Under the Hood"
      AutowiredAnnotationBeanPostProcessor. This is the internal Spring class responsible for processing the @Autowired annotation. It uses Java Reflection to find the
      annotation and inject the bean after the class is instantiated but before it's ready for use.

  1. Eliminates Boilerplate (The "New" Problem): In standard Java, if OrderService depends on OrderRepository, you have to instantiate the repository manually.
  2. Automatic Dependency Discovery: Internally, Spring uses a process called Component Scanning. When the application starts, it looks for classes marked with @Component,
      @Service, or @Repository. When it sees @Autowired, it searches its "Bean Inventory" (the ApplicationContext) for a matching object type and injects it automatically
  3. Support for Multiple Injection Types: @Autowired is flexible. You can use it in three places.
      Field Injection	Annotation is placed directly on the field.	Simplest, but makes unit testing harder without Spring.
      Setter Injection	Annotation is placed on the setter method. Good for optional dependencies that can be changed later.
      Constructor Injection	Annotation is on the constructor.	Recommended. Ensures the object is always created with its dependencies (Immutability).
  4. Handling Multiple Implementations (The Ambiguity Resolver): If you have one interface (e.g., PaymentProcessor) but two implementations (PaypalProcessor and
      StripeProcessor), @Autowired works with @Qualifier to choose the right one without you having to write logic to decide.


27. How does @ComponentScan work
    @ComponentScan is the engine that drives the automatic discovery of your beans. It tells Spring, "Look in these specific folders, find any classes with a stereotype 
    annotation, and create an object for them in the container.

  1. How It Works Internally (Step-by-Step):  The process is managed primarily by the ClassPathBeanDefinitionScanner and ComponentScanAnnotationParser:
      Scanning: When your application starts, Spring reads the basePackages defined in the annotation. If none are specified, it defaults to the package of the class 
                where the annotation is placed.
      Resource Discovery: Spring uses a ResourcePatternResolver to find all .class files within those packages and their sub-packages on the classpath.
      Metadata Reading: Instead of loading every class into memory (which would be slow and memory-intensive), Spring uses the ASM library to read the class metadata
                        directly from the bytecode.
      Candidate Filtering: It checks for "Candidate Components"—classes marked with @Component or its specializations (@Service, @Repository, @Controller, @Configuration).
      Bean Registration: For every candidate found, Spring creates a BeanDefinition (a recipe for the bean) and registers it in the BeanFactory.

  2. Default Behavior in Spring Boot: Spring starts scanning from the package containing your main class and moves downwards into all sub-packages.

    example
      @SpringBootApplication
      @ComponentScan(basePackages = {"com.ust.iot", "com.common.utils"})
      public class IoTApplication { ... }

3. Key Attributes of @ComponentScan
    Attribute                        Description  
    basePackages                     A String array specifying the packages to scan.
    basePackageClasses               A type-safe alternative. Spring scans the package of the classes provided.
    includeFilters                   Tell Spring to include classes even if they don't have a @Component annotation (e.g., scan by regex or custom type).
    excludeFilters                   Tell Spring to ignore certain classes, even if they have @Component. Useful for excluding test configurations or legacy code.
    lazyInit                         If true, the beans found by the scanner won't be created until they are first needed.


