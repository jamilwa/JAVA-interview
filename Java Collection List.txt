Collection framework

1. Lets create a list program
	a. List<String> list1 = Arrays.asList("jamil", "ansari")            // we use classes to implement an interface, LHS should always be an interface and RHS a class
	b. Collection<String> list2 = Arrays.asList("jamil", "ansari")      // we can either use the interface or its parent interface to implement it. Collection is parent of all interfaces
	c. ArrayList<Integer> list3 = new ArrayList<>()                     // this is empty list with size zero
		list3.add(45)						    // lets add elements to the empty list
		list3.add(13)
		list3.add(24)
	
	d. 	Sout(list3)					  // lets print the list. output will be [45,13,24]. This is because every class in collection has overridden toString method
	e. Integer[] arr = {45,13,24}  or int[] arr = {45,13,24}	
		 sout(arr) 					  // if we print arr then output will be some gibberish value like  java.lang.Integer;@kjfu54848
		 or [I@345fkdjf because in wrapper class like Integer or primitive type like int dont override toString method, so we dont get output as in step d.
	f. ArrayList internally uses array. whenever we add/remove an element to it, old array is destroyed from memory & a new array is generated & the reference variable points 
		to the new array. Hence its performance is slow due to this resizing and creating new array again & again. Therefore if we know the initial capacity of the arrayList then
		its better to mention it in the ArrayList declaration, like below
		ArrayList<Integer> list3 = new ArrayList<>(50)      // it will add elements to same array instead of creating new array untill its size reaches to 50.
	g. we get ArrayIndexOutofBoundException for arrays & IndexOutofBoundException for lists when we try to fetch elements at higher index than specified
	h. we can loop through elements of a list or array using for loop, for each loop like below
			for (Integer i : list3){
				sout(i)                  // we can just fetch elements but cannot perform any operation on it.
	    
		we can also loop through elements of list or array using Iterator, like below
			Iterator<Integer> itr = list3.iterator();
				while(itr.hasnext()){
					sout(itr.next())           // itr.next() fetch element & move cursor to next index

		we can also loop through elements of list or array using lambda expression, like below
				list3.forEach(i -> sout(i))

		we can also loop through elements of list or array using method reference, like below
				list3.forEach(i -> sout.out::print)
	i. Collection interface remove method takes an object whereas list remove method takes an index to remove an element.
	j. we use set(index, elemet) to replace an element at particular index
	k. use lst3.addAll(lst4)       to copy one list to another list
	
