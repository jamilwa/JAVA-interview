
	1. Whenever we have to sort objects in customized way or compare objects then we have to use two things. Comparable interface and
		Comparator( both are functional interface(has only one abstract method))
		A marker interface is an interface that doesn't have any methods or constants inside it. It provides run-time type 
		information about objects, so the compiler and JVM have additional information about the object. A marker interface 
		is also called a tagging interface. the marker interface in Java is used to indicate something to the compiler, JVM,
		or any other tool, but Annotation is a better way of doing the same thing


	2. Comparator interface is used to order the objects of a user-defined class. This interface contains 2 methods compare(Object obj1, Object obj2) and 			equals(Object element).  
	   How do the sort() method of Collections class work? 
		Internally the Sort method does call Compare method of the classes it is sorting. To compare two elements, it asks “Which is greater?”
		Compare method returns -1, 0, or 1 to say if it is less than, equal, or greater to the other. It uses this result to then determine if
		they should be swapped for their sort. 
		
		Example:
		class Student {
 			String Name;
	    		int Age;
 			
    			public Student(int Age, String Name)
    			{
			    this.Age = Age;
    			    this.Name = Name;
    			 }
 			
    			public String toString()
    			{
 				return this.Age + " " + this.Name;
    			}
			
 
		// Class 2
		// Helper class implementing Comparator interface
		class Sortbyroll implements Comparator<Student> {
		 
		    // Sorting in ascending order of roll number
		    public int compare(Student a, Student b)
		    {
		 
		        return a.Age - b.Age;
		    }
		}
		 
		// Class 3
		class Sortbyname implements Comparator<Student> {
		 
		    // Sorting in ascending order of name
		    public int compare(Student a, Student b)
		    {
		 
		        return a.Name.compareTo(b.Name);
		    }
		
 
		// Class 4
		// Main class
		class GFG {
		 
		    public static void main(String[] args)
		    {
		 
		        ArrayList<Student> ar = new ArrayList<Student>();
		 
		        ar.add(new Student(111, "Mayank"));
		        ar.add(new Student(131, "Anshul"));
		        ar.add(new Student(121, "Solanki"));
		        ar.add(new Student(101, "Aggarwal"));
		 
		        // Sorting student entries by roll number
		        Collections.sort(ar, new Sortbyroll());
		 
		        // Sorting student entries by name
		        Collections.sort(ar, new Sortbyname());
		 
		        
	3. By changing the return value inside the compare method, you can sort in any order that you wish to, for example: For descending order just change the 		positions of ‘a’ and ‘b’ in the above compare method.
	
	4. In the previous example, we have discussed how to sort the list of objects on the basis of a single field using the Comparable and Comparator interface But, 	   what if we have a requirement to sort ArrayList objects in accordance with more than one field like firstly, sort according to the student name and 		   secondly, sort according to student age.
	
	// Class 1
	// Helper class representing a Student
	class Student {
	 
	    String Name;
	    int Age;
	 
	    public Student(String Name, Integer Age)
	    {
	        this.Name = Name;
	        this.Age = Age;
	    }
	 
	    // Getter setter methods
	    public String getName() { return Name; }
	 
	    public void setName(String Name) { this.Name = Name; }
	 
	    public Integer getAge() { return Age; }
	 
	    public void setAge(Integer Age) { this.Age = Age; }
	 
	    @Override 
	    public String toString()
	    {
	        return "Customer{"
	            + "Name=" + Name + ", Age=" + Age + '}';
	    }

 
	// Class 2
	class CustomerSortingComparator
	    implements Comparator<Student> {
	 
	    @Override
	    public int compare(Student customer1, Student customer2)
	    {
	        // Comparing customers
	        int NameCompare = customer1.getName().compareTo(
	            customer2.getName());
	 
	        int AgeCompare = customer1.getAge().compareTo(
	            customer2.getAge());
	 
	        // 2nd level comparison
	        return (NameCompare == 0) ? AgeCompare
	                                  : NameCompare;


	
	class GFG {
	    public static void main(String[] args)
	    {	
	    	List<Student> ar = new ArrayList<>();
	 	
		ar.add(new Student("Ajay", 27))
		ar.add(new Student("Sneha", 23))
		ar.add(new Student("Simran", 37))
		ar.add(new Student("Ajay", 22))
		ar.add(new Student("Ajay", 29))
		ar.add(new Student("Sneha", 22))
		
	        // Iterating using Iterator
	        // before Sorting ArrayList
	        Iterator<Student> custIterator = ar.iterator();
		
		while (custIterator.hasNext()) {
		   System.out.println(custIterator.next());
		}

		Collections.sort(ar, new CustomerSortingComparator());
		
		// after Sorting ArrayList
		for (Student customer : al) {
		    System.out.println(customer);
		


	3. The Comparable interface is used to compare an object of the same class with an instance of that class.  it provides the compareTo method that takes a     		 parameter of the object of that class. 
	
	    Comparable Example 

		public class Player implements Comparable<Player> {
		  private int ranking;
  		  private String name;
  		  private int age;
    
 		   // constructor, getters, setters  
		}
    			

    		@Override
    		public int compareTo(Player otherPlayer) {
        	return Integer.compare(getRanking(),otherPlayer.getRanking());
    			}



		public static void main(String[] args) {
    			List<Player> footballTeam = new ArrayList<>();
    			
			footballTeam.add(new Player(59, "John", 20));
    			footballTeam.add(new Player(67, "Roger", 22));
    			footballTeam.add(new Player(45, "Steven", 24));
			
			Collections.sort(footballTeam);
    	

		
		Output:
		Before Sorting : [John, Roger, Steven]
		After Sorting : [Steven, John, Roger]



	// Comparable has comparTo(T o)	.  this is used when we have class in same project, so that we can use this operator
	// Comparator has compare(T o1, T o2)	this is used when we dont have class in the project, we r getting it externally from jar
