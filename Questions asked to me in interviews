1. What are SOLID Principles 
    The SOLID principles are a set of design principles for writing maintainable and scalable code. These are guidelines for developers to create software 
    that is easy to understand, Test, maintain, and scale.

    Single Responsibility Principle : a class should focus on a single task or functionality. making them easier to understand, test, and maintain.
    Open/Closed Principle : classes, modules, functions, etc. should be open for extension but closed for modification. This means that you should be able to add new
                            functionality to a class without changing its existing code. This is achieved through abstraction, such as using interfaces or abstract classes.
    Liskov Substitution Principle : a subclass should be able to substitute its parent class without changing the behavior of the program. a subclass can be used 
                                    interchangeably with its superclass. It promotes the use of inheritance and polymorphism.
    Interface Segregation Principle : Create smaller, customizable interfaces to the needs of the clients. This prevents clients from being burdened with
                                            methods they don't need, promoting cleaner and more maintainable code.
    Dependency Inversion Principle :  high-level modules should not depend on low-level modules; both should depend on abstractions. Abstractions should not depend on
                                      details, details should depend on abstractions. This principle helps 
                                      to decouple modules and promote flexibility, extensibility, and easier testing.

2. Explain why equals and hashcode method should be overridden.
    By default, the equals() method compares the content equality of two strings, which might not be suitable for your specific use case. Overriding equals() allows you
    to define your own logic for comparing object equality based on your application's requirements.
 
    If two objects are equal according to the equals() method, their hashCode() values must be equal as well. if two objects have the same hashCode() values,
    it doesn't mean they are equal. Therefore, when overriding equals(), you should also override hashCode() to ensure consistency.
    because HashSet, HashMap, and Hashtable rely on the hashCode() method.

3.  Explain SYNCHRONIZE and VOLATILE keyword
    SYNCHRONIZE ensures that only one thread can execute the synchronized block or method at any given time, preventing race conditions and ensuring thread safety.
    VOLATILE means a variables value may be modified by different threads. its value will always be read from and written to main memory, ensuring visibility of changes
    across threads.
    
4. Difference between collection and stream
        Stream: It doesn’t store data, it operates on the source data structure i.e collection.	
                it use functional interfaces like lambda.
                Streams are not modifiable i.e one can’t add or remove elements from streams.	
                Streams are iterated internally by just mentioning the operations.	
5. expain MAP and REDUCE method from streams. 
    1. A stream consists of a source followed by zero or more intermediate methods and a terminal method to process the objects obtained from the source.
  
    MAP : it is used to transform each element of a stream into another element. 
    example : List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
              List<Integer> squaredNumbers = numbers.stream()
                                     .map(n -> n * n)
                                     .collect(Collectors.toList());
              System.out.println(squaredNumbers); // Output: [1, 4, 9, 16, 25]

    REDUCE : it is used to reduce the elements of a stream to a single value. It takes two parameters: an identity value and a BinaryOperator. The identity value is the 
             initial value for the reduction operation, and the BinaryOperator specifies how two elements should be combined.    
            It returns an Optional since the stream might be empty.
    example: Optional<Integer> sum = numbers.stream()
                                       .reduce((a, b) -> a + b);
            sum.ifPresent(System.out::println); // Output: 15

6. Program denoting map(), filter(), sorted(), collect(), forEach() and reduce()  methods of Stream API. (collect map forEach sorted red filter)
       
        // demonstration of map method
        List<Integer> square  = number.stream()
                    .map(x -> x * x)
                    .collect(Collectors.toList());
 
        // create a list of String
        List<String> names = Arrays.asList(
            "Reflection", "Collection", "Stream");
 
        // demonstration of filter method
        List<String> result
          = names.stream()
            .filter(s -> s.startsWith("S"))
            .collect(Collectors.toList());
       

        // demonstration of sorted method
        List<String> show 
          = names.stream()
            .sorted()
            .collect(Collectors.toList());
       
        
        // collect method returns a set
        Set<Integer> squareSet
          = numbers.stream()
            .map(x -> x * x)
            .collect(Collectors.toSet());
       

        // demonstration of forEach method
        number.stream()
            .map(x -> x * x)
            .forEach(y -> System.out.println(y));
 
    

7. What is functional programming
        So far Java was supporting object-oriented programming. Java 8 has started supporting the functional style of programming. This makes code more concise, 
        less complex, maintainable, and easier to test compared to the legacy style of coding. A Lambda expression is an anonymous method
        that has only a parameter list and a body. The return type is always inferred based on the context. Lambda expressions work in parallel with the functional interface

       it allows you to write code that is more concise. By defining functions as values and passing them around as arguments or return values, developers
       can create more modular and reusable code.
8. what do you mean by orchestrate in microservices
    orchestration" refers to the coordination and management of multiple microservices to achieve a specific business goal or process. Orchestration involves controlling
    the flow of data and requests between different microservices, ensuring that they work together harmoniously to fulfill complex functionalities or workflows.
    Common orchestration tools and frameworks used in microservices architectures include Kubernetes, Docker Swarm, Apache Mesos, and cloud-native platforms like 
    AWS ECS (Elastic Container Service) and Azure Kubernetes Service (AKS).

9. serialVersionUID", is used in serialization to ensure that the version of the class being deserialized matches the version of the class
    that was serialized. If the serialVersionUID of the serialized object does not match the serialVersionUID of the class at the time of deserialization, then
    an InvalidClassException is thrown. It serves as a version control mechanism for serialized objects. By explicitly declaring the serialVersionUID in the code,
    you can control the serialization version of the class. The value "1L" is simply an identifier for the first version of the class. If you make changes to
    the class that affect its serialization, you should increment this value to indicate a new version.
    
9. A stored procedure(CAB SE) is a set of SQL statements that can be stored in the database and executed as a single unit. Stored procedures are used to handle 
    repetitive tasks, complex logic, or frequently executed queries, and can be invoked by applications, scripts, or even other stored procedures
        example: 
            CREATE PROCEDURE GetCustomerList
            AS
            BEGIN
                SELECT CustomerID, FirstName, LastName, Email
                FROM Customers
                ORDER BY LastName, FirstName;
           END;


    To execute this stored procedure, you would use the following SQL command: EXEC GetCustomerList;

9a.  An SQL function is a set of SQL statements that can be executed as a single unit that performs a specific task in a database management system (DBMS).

There are two types of SQL functions:

1. **Scalar functions**: These functions return a single value, such as a string, number, or date. Examples of scalar functions include `UPPER()`, `LOWER()`, `SUM()`, `AVG()`, `COUNT()`, and `NOW()`.

Here's an example of using the `UPPER()` function to convert a string to uppercase:
```sql
SELECT UPPER('hello world');
```
The result of this query would be `HELLO WORLD`.

2. **Table-valued functions**: These functions return a table as a result. Examples of table-valued functions include `CUSTOMER_ORDERS()` or `EMPLOYEE_SALARIES()`.

Here's an example of using a table-valued function to retrieve a list of orders for a specific customer:
```sql
SELECT * FROM CUSTOMER_ORDERS(123);
```
The result of this query would be a table containing all the orders for the customer with ID 123.

SQL functions can be used in `SELECT`, `INSERT`, `UPDATE`, and `DELETE` statements to perform various operations on the data stored in a database.




10. what is @qualifier 
      In the Java Spring Framework, @Qualifier is an annotation used to resolve the ambiguity between
      multiple beans of the same type. It helps specify which bean should be injected when there are multiple candidates.
    Example:
        @Autowired
        @Qualifier("specificBean")
        private MyService myService;

11. how to add custom methods to string class
        In Java, you cannot directly add methods to existing classes such as String because it is a final class. However, you can achieve similar functionality by
        creating a utility class with static methods that operate on String objects. This approach is common in Java for extending the functionality of built-in classes.

                        public class StringUtils {
                            // Custom method to reverse a string
                            public static String reverse(String str) {
                                return new StringBuilder(str).reverse().toString();
                            }
                        
                            // Custom method to check if a string is a palindrome
                            public static boolean isPalindrome(String str) {
                                String reversed = reverse(str);
                                return str.equals(reversed);
                            }

                            // Custom method to capitalize the first letter of each word in a string
                            public static String capitalizeWords(String str) {
                                String[] words = str.split("\\s+");
                                StringBuilder capitalized = new StringBuilder();
                                
                                for (String word : words) {
                                    if (word.length() > 0) {
                                        capitalized.append(Character.toUpperCase(word.charAt(0)))
                                                   .append(word.substring(1).toLowerCase())
                                                   .append(" ");
                                    }
                                }
                                
                                return capitalized.toString().trim();
                          

                Using the Custom Methods. You can now use the methods defined in the StringUtils class to perform operations on String objects.
                    public class Main {
                            public static void main(String[] args) {
                                String original = "hello world";
                                
                                // Reverse the string
                                String reversed = StringUtils.reverse(original);
                                System.out.println("Reversed: " + reversed); // Output: "dlrow olleh"
                                
                                // Check if the string is a palindrome
                                boolean isPalindrome = StringUtils.isPalindrome("madam");
                                System.out.println("Is palindrome: " + isPalindrome); // Output: true
                                
                                // Capitalize the first letter of each word
                                String capitalized = StringUtils.capitalizeWords(original);
                                System.out.println("Capitalized: " + capitalized); // Output: "Hello World"


12. how many ways to create objects 
     1. Using reflection
         example:  MyClass obj = (MyClass) Class.forName("MyClass").newInstance();
     2. Using clone() method
         example: MyClass obj1 = new MyClass();
                  MyClass obj2 = (MyClass) obj1.clone();
     3. Using factory methods
          example: MyClass obj = MyClassFactory.createMyClass();
     4. Using deserialization
          example: ObjectInputStream in = new ObjectInputStream(new FileInputStream("file.ser"));
                   MyClass obj = (MyClass) in.readObject();
     5. Using dependency injection frameworks (like Spring)
           example: ApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");
                    MyClass obj = (MyClass) context.getBean("myClass");


13. which data type used to stop a thread.  ans boolean 
14. how to create mockito mock object for database
15. what is point cut
16. what is reflection
        Reflection is found in Java Reflection API, which allows programs to inspect and manipulate the runtime behavior of applications. you can modify
        the structure and properties of classes, methods, and fields, Constructors, Annotations at runtime, even if they are private. This capability is particularly
        useful for tasks like debugging, testing, and building frameworks or libraries that need to operate on classes dynamically.

                                    import java.lang.reflect.Field;

                                                class Person {
                                                    private String name;
                                                    private int age;
                                                
                                                    public Person(String name, int age) {
                                                        this.name = name;
                                                        this.age = age;
                                                    }
                                                
                                                    // Getters
                                                    public String getName() {
                                                        return name;
                                                    }
                                                
                                                    public int getAge() {
                                                        return age;
                                                    }
                                                }
                                                
                                                public class Main {
                                                    public static void main(String[] args) {
                                                        try {
                                                            Person person = new Person("John", 30);
                                                
                                                            // Get the Class object
                                                            Class<?> personClass = person.getClass();
                                                
                                                            // Access and modify the private field 'name'
                                                            Field nameField = personClass.getDeclaredField("name");
                                                            nameField.setAccessible(true); // Make the private field accessible
                                                            System.out.println("Original Name: " + nameField.get(person)); // Output: John
                                                            nameField.set(person, "Jane");
                                                            System.out.println("Modified Name: " + nameField.get(person)); // Output: Jane
                                                
                                                            // Access and modify the private field 'age'
                                                            Field ageField = personClass.getDeclaredField("age");
                                                            ageField.setAccessible(true);
                                                            System.out.println("Original Age: " + ageField.get(person)); // Output: 30
                                                            ageField.setInt(person, 25);
                                                            System.out.println("Modified Age: " + ageField.get(person)); // Output: 25
                                                
                                                        } catch (NoSuchFieldException | IllegalAccessException e) {
                                                            e.printStackTrace();




17. Learn design patterns
28. Singleton design pattern. example 
29. what is aggregation and association
     Lets understand Aggregation, association, and composition in terms of "has-a" and "is-a" relationships.

1. Association: An association represents a "uses-a" relationship between two classes. In other words, one class uses another class to perform some functionality.
    For example, a Student class may have an association with a Course class, where a Student object takes a Course. In this case, we can say that a Student "uses"
    a Course, but a Course doesn't "have" a Student.
2. Aggregation: An aggregation represents a "has-a" relationship between two classes, where the child object can exist independently of the parent object. 
    In other words, the child object is not exclusively owned by the parent object. For example, a Team class may have an aggregation with a Player class, 
    where a Team object has multiple Player objects. In this case, we can say that a Team "has-a" Player, but a Player can also exist independently of a Team.
3. Composition: A composition also represents a "has-a" relationship between two classes, but it is a stronger relationship than aggregation. In composition, 
    the child object is exclusively owned by the parent object and cannot exist independently. For example, a Car class may have a composition with an Engine class,
    where a Car object "has-a" Engine. In this case, an Engine cannot exist independently of a Car.

To summarize, association represents a "uses-a" relationship, aggregation represents a "has-a" relationship where the child object can exist independently, 
    and composition represents a "has-a" relationship where the child object cannot exist independently.
30. steps to deploy microservices 
    1. Prepare Your Application
        writing unit and integration tests. 
        Using a build tool like Maven or Gradle to manage dependencies and build the project.
    2. Choose Your Deployment Environment
        Cloud Providers: AWS, Google Cloud Platform, Azure, etc.
        On-Premise Servers
    3. Containerize Your Application
        Containerization helps in packaging your microservices along with all their dependencies to ensure consistency across environments.
        Docker is the most popular tool for this purpose.
    4. Push to a Container Registry
        Push your Docker image to a container registry like Docker Hub, AWS ECR, Google Container Registry, etc.
    5. Set Up Your Infrastructure
        Depending on your deployment environment, set up the necessary infrastructure.
        Create a Kubernetes Cluster: You can use managed Kubernetes services like GKE (Google Kubernetes Engine), EKS (Elastic Kubernetes Service), 
        or AKS (Azure Kubernetes Service). 
        Create Deployment and Service YAML files:
    6. Deploy to Kubernetes
        kubectl apply -f deployment.yaml
        kubectl apply -f service.yaml

    7. Configure Monitoring and Logging. Tools you can use:
            Prometheus and Grafana: For monitoring.
            ELK Stack (Elasticsearch, Logstash, Kibana): For logging.
            Jaeger or Zipkin: For distributed tracing
    8. Set Up CI/CD Pipeline
        Automate the build, test, and deployment process using a CI/CD pipeline.
        CI/CD Tools: Jenkins, GitLab CI, GitHub Actions, CircleCI, etc.
        Pipeline Example (Jenkinsfile):
    9. Post-Deployment Steps
        Health Checks: Ensure the services are running correctly.
        Scaling: Adjust the number of replicas based on the load.
        Security: Set up security measures like network policies, secrets management, etc.

31. steps to create microservices 
    1. Create a Spring Boot Project
    2. Create Your First Microservice
        └── src
        ├── main
        │   ├── java
        │   │   └── com.example.microservice
        │   │       ├── MicroserviceApplication.java
        │   │       ├── controller
        │   │       ├── service
        │   │       └── repository
        │   └── resources
        │       ├── application.properties
        └── test

        Run the Application:
    3. Add More Microservices : Repeat the steps to create additional microservices. Each microservice should be a separate Spring Boot project.
    4. Configure Communication Between Microservices : Microservices often need to communicate with each other. You can use REST, messaging queues, or
        service discovery for this.
        1. Using REST: RestTemplate, Feign Client: A declarative REST client.
        2. Service Discovery with Eureka: Add Dependencies -> Create a Eureka Server -> Register Microservices with Eureka -> Configure application.properties ->
            Use Eureka Discovery for Inter-Service Communication.

    5. Database Configuration : If each microservice has its own database, configure the application.properties or application.yml for database connectivity
    6. Secure Your Microservices
    7. Deploy and Monitor


32. what is dynamic dispatch 
    Dynamic dispatch, also known as runtime polymorphism, is a mechanism by which a call to an overridden method is resolved at
    runtime rather than at compile-time. 
    How Dynamic Dispatch Works ?
    When a method is called, the Java Virtual Machine (JVM) determines the actual method to execute based on the runtime type of the object,
    not the reference type. This enables the correct method to be called even when the reference type is of a superclass.

33. what is the new feauture added to hashmap in java 8
        HashMap replaces linked list with a binary tree when the number of elements in a bucket reaches certain threshold
34. how do you see logs and how do  you create it for microservices
35. difference between stored procedure and functions
36. difference between map and flatmap
37. how does load balancing occur ?
38. if 5 microservices are there how many db will you use and how many ec2 instances will be needed
39. when request comes who will pick up first land balancer or api gateway 
40. what is api version and how can it be backtracked 
41. why do we use IntStream
        the Stream API is designed to work with objects, not primitive types directly. However, the Stream API provides special primitive-type streams to handle
        primitive values such as 
                1. IntStream: A stream of primitive ints.
                2. LongStream: A stream of primitive longs.
                3. DoubleStream

                example:   int[] intArray = {1, 2, 3, 4, 5};
                           // Using IntStream
                              IntStream intStream = Arrays.stream(intArray);
                           // Example operations on IntStream
                              int sum = intStream.sum();
        You can convert a regular Stream to a primitive-type stream using methods like mapToInt, mapToLong, or mapToDouble.
                example:  List<Integer> numbersList = Arrays.asList(1, 2, 3, 4, 5);
                          IntStream intStream = numbersList.stream().mapToInt(Integer::intValue);

        Conversely, you can convert a primitive-type stream to a regular Stream using methods like boxed().
                example:     // Convert IntStream to Stream<Integer>
                            IntStream intStream = Arrays.stream(intArray);
                            List<Integer> resultList = intStream.boxed().collect(Collectors.toList());


            example showcasing various methods available in Java 8 for working with IntStream
                    int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

        // 1. forEach
        IntStream.of(numbers).forEach(System.out::println);

        // 2. sum
        int sum = IntStream.of(numbers).sum();

        // 3. average
        OptionalDouble average = IntStream.of(numbers).average();
        System.out.println("Average: " + average.orElse(0.0));

        // 4. min
        OptionalInt min = IntStream.of(numbers).min();
        System.out.println("Min: " + min.orElse(0));

        // 5. max
        OptionalInt max = IntStream.of(numbers).max();

        // 6. count
        long count = IntStream.of(numbers).count();
        System.out.println("Count: " + count);

        // 7. summaryStatistics
        IntSummaryStatistics stats = IntStream.of(numbers).summaryStatistics();
        System.out.println("Stats: " + stats);

        // 8. filter and collect
        int[] evenNumbers = IntStream.of(numbers)
                                     .filter(n -> n % 2 == 0)
                                     .toArray();
        IntStream.of(evenNumbers).forEach(System.out::print);

        // 9. map and sum
        int squaredSum = IntStream.of(numbers)
                                  .map(n -> n * n)
                                  .sum();
        System.out.println("Sum of Squares: " + squaredSum);
        
42.   How do you create an IntStream in Java?
            using factory methods like
                IntStream.range(int startInclusive, int endExclusive) or 
                IntStream.rangeClosed(int startInclusive, int endInclusive) 
                IntStream.of(numbers[])
             or by converting other data structures like arrays or collections using
                Arrays.stream(int[] array) or 
                Collection.stream().mapToInt().
43.  why do we use interface instead of abstract classes
         interface is implemented by multiple, unrelated classes, without specifying the implementation details, allowing for greater flexibility and the ability for 
            a class to inherit behavior from multiple sources through multiple interface implementations; whereas an abstract class is better suited for sharing common
            code among closely related classes where some implementation details can be provided to subclasses.

44. Difference between THROW and THROWS 

                THROW                                                                                                    THROWS
 used to explicitly throw an exception.	                                                        Used to declare multiple exceptions that a method might throw.
 Used within a method try catch block followed by an exception object.	                        Used in method signature followed by the exception classes.
 Can handle only one exception at a time.	                                                    Can declare multiple exceptions separated by commas.
 Stops execution of the current method and looks for a catch block.	                            Allows the method to propagate the exception to the caller.
 Checked exceptions not propagated using throw only keyword                                     Checked exceptions are propagated using Throws keyword.

45. what are ACID properties
        To maintain database consistency both before and after a transaction, specific properties, known as ACID properties must be followed.
        Atomicity: either the entire transaction takes place at once or doesn’t happen at all. There is no midway i.e. transactions do not occur partially.
                   If any part of the transaction fails, the entire transaction is rolled back to its original state, ensuring data consistency and integrity.
                   Atomicity is also known as the ‘All or nothing rule

                    It involves the following two operations.
                        — Abort : If a transaction aborts, changes made to the database are not visible.
                        — Commit : If a transaction commits, changes made are visible.

                    example: transaction T consisting of T1 and T2 : Transfer of 100 from account X to account Y .
                                
                        BEFORE:         X - 500                             Y - 200
                        Transaction T     T1                                  T2
                                        READ(X)                            READ(Y)
                                        X = X - 100                        Y = Y + 100
                                        WRITE(X)                           WRITE(Y)
                        AFTER :         X = 400                            Y = 300

                        
        Consistency: ensures that a database remains in a valid state before and after a transaction.  Referring to the example above,
                    The total amount before and after the transaction must be maintained.  Constraints, such as unique keys and foreign keys,
                    must be maintained to ensure data consistency.
                                             X           Y
                    Total before T occurs = 500    +    200 =  700
                    Total after T occurs =  400    +    300 =  700
                    Therefore, the database is consistent . Inconsistency occurs in case T1 completes but T2 fails.


      Isolation: ensures that multiple transactions can occur concurrently without leading to the inconsistency of the database state. Transactions occur 
                 independently without interference. Changes occurring in a particular transaction will not be visible to any other transaction until that particular
                 change in that transaction is written to memory or has been committed. This property ensures that when multiple transactions run at the same time, 
                 the result will be the same as if they were run one after another in a specific order.
                 example :      Let X = 500,             Y = 500.
                                Consider two transactions T and T"
                                READ(X)                    READ(X)
                                X = X * 100                READ(Y)
                                WRITE(X)                   Z = X + Y
                                READ(Y)                    WRITE(Z)
                                Y = Y - 50
                                WRITE(Y)

                    Suppose T has been executed till Read (Y) and then T’’ starts. T’’ reads the correct value of X but the incorrect value of Y and sum computed by
                    T’’: (X+Y = 50, 000+500=50, 500) is thus not consistent with the sum at end of the transaction:
                    T: (X+Y = 50, 000 + 450 = 50, 450). This results in database inconsistency, due to a loss of 50 units. 
                    Hence, transactions must take place in isolation and changes should be visible only after they have been made to the main memory.


Durability: This property ensures that once the transaction has completed execution, the updates and modifications to the database are stored in and written 
            to disk and they persist even if a system failure occurs.

46. How headers are added in Swagger
    To add headers in Swagger for Java Spring Boot microservices, use Springdoc OpenAPI. You can define header parameters in your controller methods using annotations
    or configure them globally for all endpoints. 
        1. Add Dependencies: Ensure you have the Springdoc OpenAPI dependency in your pom.xml
                  org.springdoc:springdoc-openapi-ui:1.5.9
        2. Define Global Headers: define global headers in your application properties or configuration class.
                @Bean
                public OpenAPI customOpenAPI() {
                    return new OpenAPI()
                                .components(new Components()
                                .addHeaders("AUTH-TOKEN", new Header().description("Basic Auth Token").required(true)));
        3. Adding Headers in Controller Methods: you can also specify headers directly in your controller methods using the @RequestHeader annotation.
                @RestController
                @RequestMapping("/api")
                public class MyController {

                    @GetMapping("/example")
                    public ResponseEntity<String> example(@RequestHeader("AUTH-TOKEN") String authToken) {
                        // Your logic here
                        return ResponseEntity.ok("Header received: " + authToken);
    

47. Different memory types
    1. Heap Memory : The heap is the runtime data area from which memory for all class instances and arrays is allocated. It is shared among all threads.
                     Objects created using the new keyword are stored in the heap. The garbage collector manages heap memory, reclaiming memory from objects that are no
                     longer reachable.
      Characteristics: Dynamic memory allocation, Can grow and shrink as needed, Subject to garbage collection.

    2. Stack Memory : The stack is used for storing local variables and method call information. Each thread has its own stack.
                      When a method is called, a new block is created on the stack for that method's local variables and parameters. When the method execution is complete,
                      the block is popped off the stack.
      Characteristics: Memory allocation is static and follows a Last In, First Out (LIFO) order, Faster access compared to heap memory, Limited in size, leading to 
                       potential StackOverflowError if too many method calls are made. 

48. Optinal use case in project
    the Optional class is a container object that may or may not contain a non-null value. It was introduced in Java 8 as part of the java.util package to provide a 
    more expressive way to handle the absence of values, thereby reducing the likelihood of NullPointerException and improving code readability.
    
    Key Features of Optional
        1. Avoiding Null References: It is designed to represent optional values that can be absent. Instead of returning null to indicate the absence of a value,
                                     a method can return an Optional object.
        2. Type-Safe: It is a generic class, meaning it can hold any type of object. This provides type safety and eliminates the need for casting.
        3. Functional Programming: It supports functional programming paradigms, allowing you to use lambda expressions and method references.

    Creating an Optional - You can create an Optional instance in several ways:
        1. Empty Optional: To create an empty Optional, use the Optional.empty() method.    ex: Optional<String> emptyOptional = Optional.empty();
        2. Of a Non-Null Value: To create an Optional containing a non-null value, use the Optional.of(value) method. If the value is null, it will 
                                throw a NullPointerException.   ex: Optional<String> optionalValue = Optional.of("Hello");
        3. Of Nullable Value: To create an Optional that can accept a null value, use the Optional.ofNullable(value) method. If the value is null, it will create
                              an empty Optional.     ex: Optional<String> optionalNullable = Optional.ofNullable(null); // This will be empty

    Common Methods of Optional
        1. isPresent(): Returns true if there is a value present, otherwise false.  example
                if (optionalValue.isPresent()) {
                        System.out.println(optionalValue.get());
                    }

        2. ifPresent(Consumer<? super T> action): Executes the given action if a value is present.  example
                optionalValue.ifPresent(value -> System.out.println(value));

        3. get(): Returns the value if present, otherwise throws NoSuchElementException. Use this method with caution.  example
                    String value = optionalValue.get(); // Throws exception if empty

        4. orElse(T other): Returns the value if present; otherwise, returns the provided default value.
                    String value = optionalValue.orElse("Default Value");

        5. orElseGet(Supplier<? extends T> other): Returns the value if present; otherwise, invokes the provided supplier and returns the result.
                    String value = optionalValue.orElseGet(() -> "Generated Default Value");

        6. orElseThrow(Supplier<? extends X> exceptionSupplier):  Returns the value if present; otherwise, throws an exception created by the provided supplier.
                    String value = optionalValue.orElseThrow(() -> new IllegalArgumentException("Value not present"));
        7. map(Function<? super T, ? extends U> mapper): If a value is present, applies the provided mapping function to it and returns an Optional describing the result.
                                                        If no value is present, returns an empty Optional.
                    Optional<Integer> length = optionalValue.map(String::length);

        8. flatMap(Function<? super T, Optional<U>> mapper): Similar to map(), but the mapping function must return an Optional itself.
                    Optional<String> upperCaseValue = optionalValue.flatMap(value -> Optional.of(value.toUpperCase()));


example
import java.util.Optional;

Optional<String> optionalValue = Optional.ofNullable(getValue());

        // Check if a value is present
        optionalValue.ifPresent(value -> System.out.println("Value: " + value));

        // Provide a default value if not present
        String result = optionalValue.orElse("Default Value");
        System.out.println("Result: " + result);
    }

    public static String getValue() {
        // Simulating a method that may return null
        return null; // or return "Hello, World!";
    }
}


49. Steps to follow while converting monolithic to microserice
    Converting a monolithic application to microservices is a complex process that requires careful planning, execution, and ongoing management.

1. Understand the Monolith
    Analyze the Existing Application: Understand the current architecture, components, and dependencies of the monolithic application. Identify the key functionalities
                                      and how they interact with each other. 
    Document the Architecture: Create diagrams and documentation that illustrate the current state of the application, including data flow, module interactions, and 
                               technology stack.

2. Define the Microservices Strategy
    Identify Business Capabilities: Break down the monolith into distinct business capabilities or domains. Each microservice should represent a specific business
                                    function (e.g., user management, order processing, payment).
    Establish Boundaries: Define clear boundaries for each microservice. Ensure that each service is cohesive and has a single responsibility.

3. Choose the Right Technology Stack
    Select Technologies: Decide on the technology stack for the microservices, including programming languages, frameworks, databases, and communication protocols
                         (e.g., REST, gRPC, messaging queues).
    Consider DevOps Tools: Choose tools for CI/CD, containerization (e.g., Docker), orchestration (e.g., Kubernetes), and monitoring (e.g., Prometheus, Grafana).

4. Design the Microservices Architecture
    Define APIs: Design the APIs for each microservice, specifying the endpoints, request/response formats, and authentication mechanisms.
    Data Management: Decide on the data storage strategy. Each microservice should ideally have its own database to ensure loose coupling. Consider data consistency
                     and how to handle transactions across services.
    Service Communication: Determine how microservices will communicate with each other (synchronous vs. asynchronous communication).

5. Incremental Migration
    Start Small: Begin the migration process with a small, non-critical part of the application. This allows you to test the microservices architecture without 
                 disrupting the entire system.
    Strangle Pattern: Use the strangle pattern to gradually replace parts of the monolith with microservices. Route requests for specific functionalities to the 
                 new microservices while keeping the monolith operational.
    Refactor and Extract: Refactor the monolith to extract the identified microservices. This may involve rewriting parts of the codebase or creating new services
                          from scratch.

6. Implement Infrastructure and DevOps Practices
    Set Up CI/CD Pipelines: Implement continuous integration and continuous deployment pipelines to automate the build, test, and deployment processes for each
                            microservice.
    Containerization: Containerize each microservice using Docker to ensure consistency across environments and simplify deployment.
    Service Discovery: Implement service discovery mechanisms to allow microservices to find and communicate with each other dynamically.

7. Testing and Quality Assurance
    Unit and Integration Testing: Write unit tests for individual microservices and integration tests to ensure that they work together as expected.
    End-to-End Testing: Conduct end-to-end testing to validate the entire system's functionality and performance.

8. Monitoring and Logging
    Implement Monitoring: Set up monitoring tools to track the performance and health of each microservice. Use metrics to identify bottlenecks and issues.
    Centralized Logging: Implement centralized logging to collect logs from all microservices for easier debugging and analysis.

9. Deployment and Rollout
    Deploy Incrementally: Roll out the new microservices incrementally, monitoring their performance and user feedback.
    Rollback Strategy: Have a rollback strategy in place in case of issues during deployment.

10. Iterate and Improve
    Gather Feedback: Collect feedback from users and stakeholders to identify areas for improvement.
    Refine Architecture: Continuously refine the microservices architecture based on performance metrics, user feedback, and evolving business needs.
