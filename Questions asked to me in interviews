1. What are SOLID Principles 
    The SOLID principles are a set of design principles for writing maintainable and scalable code. These are guidelines for developers to create software 
    that is MUST. (maintainable, understandable, scaleable, and Testable). 

    Single Responsibility Principle : a class should focus on a single task or functionality. making them easier to understand, test, and maintain.
    Open/Closed Principle : classes, modules, functions, etc. should be open for extension but closed for modification. This means that you should be able to add new
                            functionality to a class without changing its existing code. This is achieved through abstraction, such as using interfaces or abstract classes.
    Liskov Substitution Principle : a subclass should be able to substitute its parent class without changing the behavior of the program. a subclass can be used 
                                    interchangeably with its superclass. It promotes the use of inheritance and polymorphism.
    Interface Segregation Principle : Create smaller, customizable interfaces to the needs of the classes. This prevents classes from being burdened with
                                            methods they don't need, promoting cleaner and more maintainable code.
    Dependency Inversion Principle :  high-level modules should not depend on low-level modules; both should depend on abstractions. Abstractions should not depend on
                                      details, details should depend on abstractions. This principle helps to decouple modules and promote flexibility, extensibility,
                                      and easier testing.


2. Explain why equals and hashcode method should be overridden.
    By default, the equals() method compares the content equality of two strings, which might not be suitable for your specific use case. Overriding equals() allows you
    to define your own logic for comparing object equality based on your application's requirements.
 
    If two objects are equal according to the equals() method, their hashCode() values must be equal as well. if two objects have the same hashCode() values,
    it doesn't mean they are equal. Therefore, when overriding equals(), you should also override hashCode() to ensure consistency.
    because HashSet, HashMap, and Hashtable rely on the hashCode() method.

3.  
    
4. Difference between collection and stream
        Stream: It doesn’t store data, it operates on the source data structure i.e collection.	
                it use functional interfaces like lambda.
                Streams are not modifiable i.e one can’t add or remove elements from streams.	
                Streams are iterated internally by just mentioning the operations.	
5. expain MAP and REDUCE method from streams. 
    1. A stream consists of a source followed by zero or more intermediate methods and a terminal method to process the objects obtained from the source.
  
    MAP : it is used to transform each element of a stream into another element. 
    example : List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
              List<Integer> squaredNumbers = numbers.stream()
                                     .map(n -> n * n)
                                     .collect(Collectors.toList());
              System.out.println(squaredNumbers); // Output: [1, 4, 9, 16, 25]

    REDUCE : it is used to reduce the elements of a stream to a single value. It takes two parameters: an identity value and a BinaryOperator. The identity value is the 
             initial value for the reduction operation, and the BinaryOperator specifies how two elements should be combined.    
            It returns an Optional since the stream might be empty.
    example: Optional<Integer> sum = numbers.stream()
                                       .reduce((a, b) -> a + b);
            sum.ifPresent(System.out::println); // Output: 15

6. Differnce between pathvariable and requestParam
Path Variable
    
        @RequestMapping("/users/{id}")
        public String getUser ById(@PathVariable("id") Long id) {
            return "User  ID: " + id;

        url:-    example.com/users/123

Reqeust Param

        @RequestMapping("/users")
        public String getUser ByAge(@RequestParam("age") Integer age) {
            return "User  Age: " + age;

        url:-    example.com/users?id=123



7. 
8. what do you mean by orchestrate in microservices
    orchestration" refers to the coordination and management of multiple microservices to achieve a specific business goal or process. Orchestration involves controlling
    the flow of data and requests between different microservices, ensuring that they work together harmoniously to fulfill complex functionalities or workflows.
    Common orchestration tools and frameworks used in microservices architectures include Kubernetes, Docker Swarm, Apache Mesos, and cloud-native platforms like 
    AWS ECS (Elastic Container Service) and Azure Kubernetes Service (AKS).

9. serialVersionUID", is used in serialization to ensure that the version of the class being deserialized matches the version of the class
    that was serialized. If the serialVersionUID of the serialized object does not match the serialVersionUID of the class at the time of deserialization, then
    an InvalidClassException is thrown. It serves as a version control mechanism for serialized objects. By explicitly declaring the serialVersionUID in the code,
    you can control the serialization version of the class. The value "1L" is simply an identifier for the first version of the class. If you make changes to
    the class that affect its serialization, you should increment this value to indicate a new version.
    
9. A stored procedure(CAB SE) is a set of SQL statements that can be stored in the database and executed as a single unit. Stored procedures are used to handle 
    repetitive tasks, complex logic, or frequently executed queries, and can be invoked by applications, scripts, or even other stored procedures
        example: 
            CREATE PROCEDURE GetCustomerList
            AS
            BEGIN
                SELECT CustomerID, FirstName, LastName, Email
                FROM Customers
                ORDER BY LastName, FirstName;
           END;


    To execute this stored procedure, you would use the following SQL command: EXEC GetCustomerList;

9a.  An SQL function is a set of SQL statements that can be executed as a single unit that performs a specific task in a database management system (DBMS).

There are two types of SQL functions:

1. Scalar functions: These functions return a single value, such as a string, number, or date. Examples of scalar functions include UPPER(), LOWER(), SUM(), AVG(), COUNT(), and NOW().

Here's an example of using the UPPER() function to convert a string to uppercase:
sql
SELECT UPPER('hello world');

The result of this query would be HELLO WORLD.

2. Table-valued functions: These functions return a table as a result. Examples of table-valued functions include CUSTOMER_ORDERS() or EMPLOYEE_SALARIES().

Here's an example of using a table-valued function to retrieve a list of orders for a specific customer:
sql
SELECT * FROM CUSTOMER_ORDERS(123);

The result of this query would be a table containing all the orders for the customer with ID 123.

SQL functions can be used in SELECT, INSERT, UPDATE, and DELETE statements to perform various operations on the data stored in a database.




10. what is @qualifier 
      In the Java Spring Framework, @Qualifier is an annotation used to resolve the ambiguity between
      multiple beans of the same type. It helps specify which bean should be injected when there are multiple candidates.
    Example:
        @Autowired
        @Qualifier("specificBean")
        private MyService myService;

11. how to add custom methods to string class
        In Java, you cannot directly add methods to existing classes such as String because it is a final class. However, you can achieve similar functionality by
        creating a utility class with static methods that operate on String objects. This approach is common in Java for extending the functionality of built-in classes.

                        public class StringUtils {
                            // Custom method to reverse a string
                            public static String reverse(String str) {
                                return new StringBuilder(str).reverse().toString();
                            }
                        
                            // Custom method to check if a string is a palindrome
                            public static boolean isPalindrome(String str) {
                                String reversed = reverse(str);
                                return str.equals(reversed);
                            }

                            // Custom method to capitalize the first letter of each word in a string
                            public static String capitalizeWords(String str) {
                                String[] words = str.split("\\s+");
                                StringBuilder capitalized = new StringBuilder();
                                
                                for (String word : words) {
                                    if (word.length() > 0) {
                                        capitalized.append(Character.toUpperCase(word.charAt(0)))
                                                   .append(word.substring(1).toLowerCase())
                                                   .append(" ");
                                    }
                                }
                                
                                return capitalized.toString().trim();
                          

                Using the Custom Methods. You can now use the methods defined in the StringUtils class to perform operations on String objects.
                    public class Main {
                            public static void main(String[] args) {
                                String original = "hello world";
                                
                                // Reverse the string
                                String reversed = StringUtils.reverse(original);
                                System.out.println("Reversed: " + reversed); // Output: "dlrow olleh"
                                
                                // Check if the string is a palindrome
                                boolean isPalindrome = StringUtils.isPalindrome("madam");
                                System.out.println("Is palindrome: " + isPalindrome); // Output: true
                                
                                // Capitalize the first letter of each word
                                String capitalized = StringUtils.capitalizeWords(original);
                                System.out.println("Capitalized: " + capitalized); // Output: "Hello World"


12. how many ways to create objects    ObC FRDDi
     1. Using reflection
         example:  MyClass obj = (MyClass) Class.forName("MyClass").newInstance();
     2. Using clone() method
         example: MyClass obj1 = new MyClass();
                  MyClass obj2 = (MyClass) obj1.clone();
     3. Using factory methods
          example: MyClass obj = MyClassFactory.createMyClass();
     4. Using deserialization
          example: ObjectInputStream in = new ObjectInputStream(new FileInputStream("file.ser"));
                   MyClass obj = (MyClass) in.readObject();
     5. Using dependency injection frameworks (like Spring)
           example: ApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");
                    MyClass obj = (MyClass) context.getBean("myClass");


13. which data type used to stop a thread.  ans boolean 
14. how to create mockito mock object for database
15. what is point cut
16. what is reflection - (Runtime Behavior)
        Reflection is found in Java Reflection API, which allows programs to inspect and manipulate the runtime behavior of applications. you can modify
        the structure and properties of classes, methods, and fields, Constructors, Annotations at runtime, even if they are private. This capability is particularly
        useful for tasks like debugging, testing, and building frameworks or libraries that need to operate on classes dynamically.

                                    import java.lang.reflect.Field;

                                                class Person {
                                                    private String name;
                                                    private int age;
                                                
                                                    public Person(String name, int age) {
                                                        this.name = name;
                                                        this.age = age;
                                                    }
                                                
                                                    // Getters
                                                    public String getName() {
                                                        return name;
                                                    }
                                                
                                                    public int getAge() {
                                                        return age;
                                                    }
                                                }
                                                
                                                public class Main {
                                                    public static void main(String[] args) {
                                                        try {
                                                            Person person = new Person("John", 30);
                                                
                                                            // Get the Class object
                                                            Class<?> personClass = person.getClass();
                                                
                                                            // Access and modify the private field 'name'
                                                            Field nameField = personClass.getDeclaredField("name");
                                                            nameField.setAccessible(true); // Make the private field accessible
                                                            System.out.println("Original Name: " + nameField.get(person)); // Output: John
                                                            nameField.set(person, "Jane");
                                                            System.out.println("Modified Name: " + nameField.get(person)); // Output: Jane
                                                
                                                            // Access and modify the private field 'age'
                                                            Field ageField = personClass.getDeclaredField("age");
                                                            ageField.setAccessible(true);
                                                            System.out.println("Original Age: " + ageField.get(person)); // Output: 30
                                                            ageField.setInt(person, 25);
                                                            System.out.println("Modified Age: " + ageField.get(person)); // Output: 25
                                                
                                                        } catch (NoSuchFieldException | IllegalAccessException e) {
                                                            e.printStackTrace();


29. what is aggregation and association
     Lets understand Aggregation, association, and composition in terms of "has-a" and "is-a" relationships.

1. Association: An association represents a "uses-a" relationship between two classes. In other words, one class uses another class to perform some functionality.
    For example, a Student class may have an association with a Course class, where a Student object takes a Course. In this case, we can say that a Student "uses"
    a Course, but a Course doesn't "have" a Student.
2. Aggregation: An aggregation represents a "has-a" relationship between two classes, where the child object can exist independently of the parent object. 
    In other words, the child object is not exclusively owned by the parent object. For example, a Team class may have an aggregation with a Player class, 
    where a Team object has multiple Player objects. In this case, we can say that a Team "has-a" Player, but a Player can also exist independently of a Team.
3. Composition: A composition also represents a "has-a" relationship between two classes, but it is a stronger relationship than aggregation. In composition, 
    the child object is exclusively owned by the parent object and cannot exist independently. For example, a Car class may have a composition with an Engine class,
    where a Car object "has-a" Engine. In this case, an Engine cannot exist independently of a Car.

To summarize, association represents a "uses-a" relationship, aggregation represents a "has-a" relationship where the child object can exist independently, 
    and composition represents a "has-a" relationship where the child object cannot exist independently.
30. steps to deploy microservices   (App, DEnv, Containerize, Push to Container registry, Infrastructure, Deploye to Kubernets, Monitor & logging)
    1. Prepare Your Application
        writing unit and integration tests. 
        Using a build tool like Maven or Gradle to manage dependencies and build the project.
    2. Choose Your Deployment Environment
        Cloud Providers: AWS, Google Cloud Platform, Azure, etc.
        On-Premise Servers
    3. Containerize Your Application
        Containerization helps in packaging your microservices along with all their dependencies to ensure consistency across environments.
        Docker is the most popular tool for this purpose.
    4. Push to a Container Registry
        Push your Docker image to a container registry like Docker Hub, AWS ECR, Google Container Registry, etc.
    5. Set Up Your Infrastructure
        Depending on your deployment environment, set up the necessary infrastructure.
        Create a Kubernetes Cluster: You can use managed Kubernetes services like GKE (Google Kubernetes Engine), EKS (Elastic Kubernetes Service), 
        or AKS (Azure Kubernetes Service). 
        Create Deployment and Service YAML files:
    6. Deploy to Kubernetes
        kubectl apply -f deployment.yaml
        kubectl apply -f service.yaml

    7. Configure Monitoring and Logging. Tools you can use:
            Prometheus and Grafana: For monitoring.
            ELK Stack (Elasticsearch, Logstash, Kibana): For logging.
            Jaeger or Zipkin: For distributed tracing
    8. Set Up CI/CD Pipeline
        Automate the build, test, and deployment process using a CI/CD pipeline.
        CI/CD Tools: Jenkins, GitLab CI, GitHub Actions, CircleCI, etc.
        Pipeline Example (Jenkinsfile):
    9. Post-Deployment Steps
        Health Checks: Ensure the services are running correctly.
        Scaling: Adjust the number of replicas based on the load.
        Security: Set up security measures like network policies, secrets management, etc.

31. steps to create microservices 
    1. Create a Spring Boot Project
    2. Create Your First Microservice
        └── src
        ├── main
        │   ├── java
        │   │   └── com.example.microservice
        │   │       ├── MicroserviceApplication.java
        │   │       ├── controller
        │   │       ├── service
        │   │       └── repository
        │   └── resources
        │       ├── application.properties
        └── test

        Run the Application:
    3. Add More Microservices : Repeat the steps to create additional microservices. Each microservice should be a separate Spring Boot project.
    4. Configure Communication Between Microservices : Microservices often need to communicate with each other. You can use REST, messaging queues, or
        service discovery for this.
        1. Using REST: RestTemplate, Feign Client: A declarative REST client.
        2. Service Discovery with Eureka: Add Dependencies -> Create a Eureka Server -> Register Microservices with Eureka -> Configure application.properties ->
            Use Eureka Discovery for Inter-Service Communication.

    5. Database Configuration : If each microservice has its own database, configure the application.properties or application.yml for database connectivity
    6. Secure Your Microservices
    7. Deploy and Monitor


32. what is dynamic dispatch 
    Dynamic dispatch, also known as runtime polymorphism, is a mechanism by which a call to an overridden method is resolved at
    runtime rather than at compile-time. 
    How Dynamic Dispatch Works ?
    When a method is called, the Java Virtual Machine (JVM) determines the actual method to execute based on the runtime type of the object,
    not the reference type. This enables the correct method to be called even when the reference type is of a superclass.

33. what is the new feauture added to hashmap in java 8
        HashMap replaces linked list with a binary tree when the number of elements in a bucket reaches certain threshold
34. how do you see logs and how do  you create it for microservices
35. difference between stored procedure and functions
36. difference between map and flatmap
37. how does load balancing occur ?
38. if 5 microservices are there how many db will you use and how many ec2 instances will be needed
39. when request comes who will pick up first land balancer or api gateway 
40. what is api version and how can it be backtracked 
41. 
43.  why do we use interface instead of abstract classes
         interface is implemented by multiple, unrelated classes, without specifying the implementation details, allowing for greater flexibility and the ability for 
            a class to inherit behavior from multiple sources through multiple interface implementations; whereas an abstract class is better suited for sharing common
            code among closely related classes where some implementation details can be provided to subclasses.

44. Difference between THROW and THROWS 

                THROW                                                                                                    THROWS
 used to explicitly throw an exception.	                                                        Used to declare multiple exceptions that a method might throw.
 Used within a method try catch block followed by an exception object.	                        Used in method signature followed by the exception classes.
 Can handle only one exception at a time.	                                                    Can declare multiple exceptions separated by commas.
 Stops execution of the current method and looks for a catch block.	                            Allows the method to propagate the exception to the caller.
 Checked exceptions not propagated using throw only keyword                                     Checked exceptions are propagated using Throws keyword.

45. what are ACID properties
        To maintain database consistency both before and after a transaction, specific properties, known as ACID properties must be followed.
        Atomicity: either the entire transaction takes place at once or doesn’t happen at all. There is no midway i.e. transactions do not occur partially.
                   If any part of the transaction fails, the entire transaction is rolled back to its original state, ensuring data consistency and integrity.
                   Atomicity is also known as the ‘All or nothing rule

                    It involves the following two operations.
                        — Abort : If a transaction aborts, changes made to the database are not visible.
                        — Commit : If a transaction commits, changes made are visible.

                    example: transaction T consisting of T1 and T2 : Transfer of 100 from account X to account Y .
                                
                        BEFORE:         X - 500                             Y - 200
                        Transaction T     T1                                  T2
                                        READ(X)                            READ(Y)
                                        X = X - 100                        Y = Y + 100
                                        WRITE(X)                           WRITE(Y)
                        AFTER :         X = 400                            Y = 300

                        
       Consistency: ensures that a database remains in a valid state before and after a transaction.  Referring to the example above,
                    The total amount before and after the transaction must be maintained.  Constraints, such as unique keys and foreign keys,
                    must be maintained to ensure data consistency.
                                             X           Y
                    Total before T occurs = 500    +    200 =  700
                    Total after T occurs =  400    +    300 =  700
                    Therefore, the database is consistent . Inconsistency occurs in case T1 completes but T2 fails.


      Isolation: ensures that multiple transactions can occur concurrently without leading to the inconsistency of the database state. Transactions occur 
                 independently without interference. Changes occurring in a particular transaction will not be visible to any other transaction until that particular
                 change in that transaction is written to memory or has been committed. This property ensures that when multiple transactions run at the same time, 
                 the result will be the same as if they were run one after another in a specific order.
                 example :      Let X = 500,             Y = 500.
                                Consider two transactions T and T"
                                READ(X)                    READ(X)
                                X = X * 100                READ(Y)
                                WRITE(X)                   Z = X + Y
                                READ(Y)                    WRITE(Z)
                                Y = Y - 50
                                WRITE(Y)

                    Suppose T has been executed till Read (Y) and then T’’ starts. T’’ reads the correct value of X but the incorrect value of Y and sum computed by
                    T’’: (X+Y = 50, 000+500=50, 500) is thus not consistent with the sum at end of the transaction:
                    T: (X+Y = 50, 000 + 450 = 50, 450). This results in database inconsistency, due to a loss of 50 units. 
                    Hence, transactions must take place in isolation and changes should be visible only after they have been made to the main memory.


        Durability: This property ensures that once the transaction has completed execution, the updates and modifications to the database are stored in and written 
            to disk and they persist even if a system failure occurs.

46. How headers are added in Swagger
    To add headers in Swagger for Java Spring Boot microservices, use Springdoc OpenAPI. You can define header parameters in your controller methods using annotations
    or configure them globally for all endpoints. 
        1. Add Dependencies: Ensure you have the Springdoc OpenAPI dependency in your pom.xml
                  org.springdoc:springdoc-openapi-ui:1.5.9
        2. Define Global Headers: define global headers in your application properties or configuration class.
                @Bean
                public OpenAPI customOpenAPI() {
                    return new OpenAPI()
                                .components(new Components()
                                .addHeaders("AUTH-TOKEN", new Header().description("Basic Auth Token").required(true)));
        3. Adding Headers in Controller Methods: you can also specify headers directly in your controller methods using the @RequestHeader annotation.
                @RestController
                @RequestMapping("/api")
                public class MyController {

                    @GetMapping("/example")
                    public ResponseEntity<String> example(@RequestHeader("AUTH-TOKEN") String authToken) {
                        // Your logic here
                        return ResponseEntity.ok("Header received: " + authToken);
    

47. Different memory types
    1. Heap Memory : The heap is the runtime data area from which memory for all class instances and arrays is allocated. It is shared among all threads.
                     Objects created using the new keyword are stored in the heap. The garbage collector manages heap memory, reclaiming memory from objects that are no
                     longer reachable.
      Characteristics: Dynamic memory allocation, Can grow and shrink as needed, Subject to garbage collection.

    2. Stack Memory : The stack is used for storing local variables and method call information. Each thread has its own stack.
                      When a method is called, a new block is created on the stack for that method's local variables and parameters. When the method execution is complete,
                      the block is popped off the stack.
      Characteristics: Memory allocation is static and follows a Last In, First Out (LIFO) order, Faster access compared to heap memory, Limited in size, leading to 
                       potential StackOverflowError if too many method calls are made. 


49. Steps to follow while converting monolithic to microserice
    Converting a monolithic application to microservices is a complex process that requires careful planning, execution, and ongoing management.

1. Understand the Monolith
    Analyze the Existing Application: Understand the current architecture, components, and dependencies of the monolithic application. Identify the key functionalities
                                      and how they interact with each other. 
    Document the Architecture: Create diagrams and documentation that illustrate the current state of the application, including data flow, module interactions, and 
                               technology stack.

2. Define the Microservices Strategy
    Identify Business Capabilities: Break down the monolith into distinct business capabilities or domains. Each microservice should represent a specific business
                                    function (e.g., user management, order processing, payment).
    Establish Boundaries: Define clear boundaries for each microservice. Ensure that each service is cohesive and has a single responsibility.

3. Choose the Right Technology Stack
    Select Technologies: Decide on the technology stack for the microservices, including programming languages, frameworks, databases, and communication protocols
                         (e.g., REST, gRPC, messaging queues).
    Consider DevOps Tools: Choose tools for CI/CD, containerization (e.g., Docker), orchestration (e.g., Kubernetes), and monitoring (e.g., Prometheus, Grafana).

4. Design the Microservices Architecture
    Define APIs: Design the APIs for each microservice, specifying the endpoints, request/response formats, and authentication mechanisms.
    Data Management: Decide on the data storage strategy. Each microservice should ideally have its own database to ensure loose coupling. Consider data consistency
                     and how to handle transactions across services.
    Service Communication: Determine how microservices will communicate with each other (synchronous vs. asynchronous communication).

5. Incremental Migration
    Start Small: Begin the migration process with a small, non-critical part of the application. This allows you to test the microservices architecture without 
                 disrupting the entire system.
    Strangle Pattern: Use the strangle pattern to gradually replace parts of the monolith with microservices. Route requests for specific functionalities to the 
                 new microservices while keeping the monolith operational.
    Refactor and Extract: Refactor the monolith to extract the identified microservices. This may involve rewriting parts of the codebase or creating new services
                          from scratch.

6. Implement Infrastructure and DevOps Practices
    Set Up CI/CD Pipelines: Implement continuous integration and continuous deployment pipelines to automate the build, test, and deployment processes for each
                            microservice.
    Containerization: Containerize each microservice using Docker to ensure consistency across environments and simplify deployment.
    Service Discovery: Implement service discovery mechanisms to allow microservices to find and communicate with each other dynamically.

7. Testing and Quality Assurance
    Unit and Integration Testing: Write unit tests for individual microservices and integration tests to ensure that they work together as expected.
    End-to-End Testing: Conduct end-to-end testing to validate the entire system's functionality and performance.

8. Monitoring and Logging
    Implement Monitoring: Set up monitoring tools to track the performance and health of each microservice. Use metrics to identify bottlenecks and issues.
    Centralized Logging: Implement centralized logging to collect logs from all microservices for easier debugging and analysis.

9. Deployment and Rollout
    Deploy Incrementally: Roll out the new microservices incrementally, monitoring their performance and user feedback.
    Rollback Strategy: Have a rollback strategy in place in case of issues during deployment.

10. Iterate and Improve
    Gather Feedback: Collect feedback from users and stakeholders to identify areas for improvement.
    Refine Architecture: Continuously refine the microservices architecture based on performance metrics, user feedback, and evolving business needs.

11. how to design a webservice when there are lakhs of request being requested interview question
    1. Microservices Architecture Principles
        Decomposition: Break down the application into smaller, focused microservices that handle specific business capabilities. This allows for independent scaling
                        and deployment.
        Single Responsibility: Each microservice should have a single responsibility, making it easier to optimize and scale.

    2. Scalability
        Horizontal Scaling: Design microservices to be stateless so they can be easily replicated across multiple instances. Use load balancers to distribute incoming
                            requests evenly.
        Auto-Scaling: Implement auto-scaling mechanisms based on metrics like CPU usage, memory consumption, or request rates to dynamically adjust the number of service
                            instances.

    3. Asynchronous Communication
        Message Queues: Use message brokers (e.g., RabbitMQ, Kafka) to decouple services and handle spikes in traffic. This allows services to process requests 
                        asynchronously, smoothing out load.
        In-Memory Caching: Use caching solutions (e.g., Redis, Memcached) to store frequently accessed data in memory, reducing the load on databases and improving
                        response times.

    5. Database Optimization
        Database Sharding: Distribute data across multiple databases to reduce contention and improve read/write performance.
        Read Replicas: Use read replicas to handle read-heavy workloads, allowing the primary database to focus on write operations.

    6. Load Balancing
        API Gateway: Use an API gateway to manage traffic, route requests to appropriate services, and handle cross-cutting concerns like authentication and logging.

    8. Resilience and Fault Tolerance
        Circuit Breaker Pattern: Implement circuit breakers to prevent cascading failures and allow services to recover gracefully.
        Retries and Backoff Strategies: Use retries with exponential backoff for transient failures to improve reliability without overwhelming services.


12. fault tolerance
        Fault tolerance in microservices is the ability of a system to continue operating properly even when some components fail. resilient microservices
        Fault tolerance can help prevent downtime, data loss, and service degradation. It can also improve the user experience and trust. 
        Fault tolerance is important because it helps to ensure business continuity and the high availability of critical systems and applications. 
        Fault tolerance is implemented by using spare or redundant subsystems. When a subsystem fails, another subsystem takes over its work, usually almost seamlessly. 

        Here are some strategies for implementing fault tolerance in microservices: 
             Timeout pattern: Sets a maximum time for a request to complete. If a response isn't received within that time, the request is considered failed. 
             Circuit breaker: Monitors for a specified number of successful or failed calls to the system. If the failure threshold is reached, the circuit breaker opens,
                              and subsequent calls fail immediately. 
             Bulkhead: Isolates critical services from non-critical services. This prevents failure of one service from impacting others. 
             Ensure that security measures (e.g., authentication, authorization, encryption) are built into the design without compromising performance.3.


13. what is rest architecture design principles in microservices
        Some design principles of REST APIs and microservices include: 
 
        Separation of concerns: Microservices should be self-contained and have a single responsibility. This allows for independent development, deployment, and scaling 
                                of each service. 
        Loose coupling: Microservices should store their information in their own data store. This allows for flexibility in choosing the most appropriate data store for
                        the application's needs. 
        Decentralization: Microservices architecture is decentralized, meaning it doesn't require a single platform, technology, or programming language. 
 
        Scalability: Microservices are mapped to business domains, allowing each service to be scaled independently. 
 
        Design for failure: Microservices should be designed to handle failures gracefully. This can be done with mechanisms like circuit breakers, retries, and fallbacks. 
 
        Interface segregation: Interfaces used for each service should be specific to the users who interact with them. 

14. relational vs non relational db

15. Difference between Call by Value and Call by Reference
        the terms call by value and call by reference refer to how arguments are passed to functions or methods. Java uses call by value for all method arguments. For primitive types, this means passing a copy of the value. 
        For objects, it means passing a copy of the reference to the object.
    Call by Value : a copy of the actual value of the argument is passed to the function. This means that changes made to the parameter inside the function do not affect the original argument.
                        A new memory location is created for the parameter in the function, which holds the copy of the value. 
                        primitive data types (like int, float, char, etc.) are passed by value
                        
    example:
    public static void main(String[] args) {
        int number = 10;
        System.out.println("Before: " + number); // Output: 10
        modifyValue(number);
        System.out.println("After: " + number);  // Output: 10
    }

    public static void modifyValue(int num) {
        num = 20; // This change does not affect the original variable
    }


    Call by Reference : a reference (or address) to the actual data is passed to the function. This means that changes made to the parameter inside the function will affect the original argument
                        No new memory location is created for the parameter; instead, the function operates on the original data's memory location.
                        object references are also passed by value, You can modify the object's state, but you cannot change the reference to point to a new object.
                        

