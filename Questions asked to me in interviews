1. What are SOLID Principles
    The SOLID principles are a set of design principles for writing maintainable and scalable object-oriented software. These are guidelines to aid developers in creating 
    software that is easy to understand, maintain, and extend.

    Single Responsibility Principle : a class should have only one responsibility. making them easier to understand, test, and maintain.
    Open/Closed Principle : software entities (classes, modules, functions, etc.) should be open for extension but closed for modification. This means that you should be
                                able to extend the behavior of a module without modifying its source code. This is achieved through the use of abstraction and polymorphism.
    Liskov Substitution Principle : a subclass should be able to substitute its parent class without changing the behavior by the client code.
    Interface Segregation Principle : segregation of interfaces into smaller, customizeable to the needs of the clients. This prevents clients from being burdened with
                                            methods they don't need, promoting cleaner and more maintainable code.
    Dependency Inversion Principle : The Dependency Inversion Principle advocates that high-level modules should not depend on low-level modules; both should depend on
                                  abstractions. Additionally, abstractions should not depend on details; rather, details should depend on abstractions. This principle helps 
                                  to decouple modules and promote flexibility, extensibility, and easier testing.

2. Explain why equals and hashcode method should be overridden.
    overriding the equals() and hashCode() methods is essential to ensure consistent and correct behavior when working with object equality and collections in Java. 
    It allows you to define custom equality semantics tailored to your application's needs and ensures the proper functioning of hash-based collections.
    The equals() and hashCode() methods are fundamental to Java and play a crucial role, especially when dealing with collections like HashSet, HashMap, and Hashtable.
    
    By default, the equals() method compares object references (memory addresses), which might not be suitable for your specific use case. Overriding equals() allows you
    to define your own logic for comparing object equality based on your application's requirements.

    If two objects are equal according to the equals() method, their hashCode() values must be equal as well. if two objects have the same hashCode() values,
    it doesn't mean they are equal. Therefore, when overriding equals(), you should also override hashCode() to ensure consistency and symmetry.

    If you override equals() but not hashCode(), you might encounter unexpected behavior as objects that are considered equal might not be stored or retrieved correctly. 
    HashSet, HashMap, and Hashtable rely on the hashCode() method.

    If hashCode() is not overridden, it might lead to performance issues such as hash collisions when dealing with large collections, the performance of operations 
    like insertion, deletion, and retrieval depends on the efficiency of the hashCode() method. 

3.  Explain SYNCHRONIZE and VOLATILE keyword
    SYNCHRONIZE ensures that only one thread can execute the synchronized block or method at any given time, preventing race conditions and ensuring thread safety.
    VOLATILE meaning a variables value may be modified by different threads. its value will always be read from and written to main memory, ensuring visibility of changes
    across threads.
    They address different aspects of concurrency control and are used in different scenarios depending on the requirements of the application.

4. Difference between collection and stream
5. expain MAP and REDUCE method from streams.
    Important Points/Observations of Java Stream
    1. A stream consists of a source followed by zero or more intermediate methods combined together and a terminal method to process the objects obtained from the source.
    2. Stream is used to compute elements as per the pipelined methods without altering the original value of the object.

    MAP : it is used to transform each element of a stream into another element. 
    example : List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
              List<Integer> squaredNumbers = numbers.stream()
                                     .map(n -> n * n)
                                     .collect(Collectors.toList());
              System.out.println(squaredNumbers); // Output: [1, 4, 9, 16, 25]

    REDUCE : it is used to reduce the elements of a stream to a single value. It takes two parameters: an identity value and a BinaryOperator. The identity value is the 
             initial value for the reduction operation, and the BinaryOperator specifies how two elements should be combined.    
            It returns an Optional since the stream might be empty.
    example: List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
             Optional<Integer> sum = numbers.stream()
                               .reduce((a, b) -> a + b);
            sum.ifPresent(System.out::println); // Output: 15

6. Program denoting map(), filterr(), sorted(), collect(), forEach() and reduce()  methods of Stream API.
    // create a list of integers
        List<Integer> number = Arrays.asList(2, 3, 4, 5); 
 
        // demonstration of map method
        List<Integer> square 
          = number.stream()
            .map(x -> x * x)
            .collect(Collectors.toList());
 
        // create a list of String
        List<String> names = Arrays.asList(
            "Reflection", "Collection", "Stream");
 
        // demonstration of filter method
        List<String> result
          = names.stream()
            .filter(s -> s.startsWith("S"))
            .collect(Collectors.toList());
       
        System.out.println(result);
 
        // demonstration of sorted method
        List<String> show 
          = names.stream()
            .sorted()
            .collect(Collectors.toList());
       
        System.out.println(show);
 
        // create a list of integers
        List<Integer> numbers
            = Arrays.asList(2, 3, 4, 5, 2);
 
        // collect method returns a set
        Set<Integer> squareSet
          = numbers.stream()
            .map(x -> x * x)
            .collect(Collectors.toSet());
       
        System.out.println(squareSet);
 
        // demonstration of forEach method
        number.stream()
            .map(x -> x * x)
            .forEach(y -> System.out.println(y));
 
        // demonstration of reduce method
        int even 
          = number.stream()
            .filter(x -> x % 2 == 0)
            .reduce(0, (ans, i) -> ans + i);
 
        System.out.println(even);
    }
    

7. What is functional programming
8. what do you mean by orchestrate in microservices
    orchestration" refers to the coordination and management of multiple microservices to achieve a specific business goal or process. Orchestration involves controlling
    the flow of data and requests between different microservices, ensuring that they work together harmoniously to fulfill complex functionalities or workflows.
    Common orchestration tools and frameworks used in microservices architectures include Kubernetes, Docker Swarm, Apache Mesos, and cloud-native platforms like 
    AWS ECS (Elastic Container Service) and Azure Kubernetes Service (AKS).
    
