1. What are SOLID Principles
    The SOLID principles are a set of design principles for writing maintainable and scalable object-oriented software. These are guidelines to aid developers in creating 
    software that is easy to understand, maintain, and extend.

    Single Responsibility Principle : a class should have only one responsibility. making them easier to understand, test, and maintain.
    Open/Closed Principle : software entities (classes, modules, functions, etc.) should be open for extension but closed for modification. This means that you should be
                                able to extend the behavior of a module without modifying its source code. This is achieved through the use of abstraction and polymorphism.
    Liskov Substitution Principle : a subclass should be able to substitute its parent class without changing the behavior by the client code.
    Interface Segregation Principle : segregation of interfaces into smaller, customizeable to the needs of the clients. This prevents clients from being burdened with
                                            methods they don't need, promoting cleaner and more maintainable code.
    Dependency Inversion Principle : The Dependency Inversion Principle advocates that high-level modules should not depend on low-level modules; both should depend on
                                  abstractions. Additionally, abstractions should not depend on details; rather, details should depend on abstractions. This principle helps 
                                  to decouple modules and promote flexibility, extensibility, and easier testing.

2. Explain why equals and hashcode method should be overridden.
    By default, the equals() method compares object references (memory addresses), which might not be suitable for your specific use case. Overriding equals() allows you
    to define your own logic for comparing object equality based on your application's requirements.
 
    If two objects are equal according to the equals() method, their hashCode() values must be equal as well. if two objects have the same hashCode() values,
    it doesn't mean they are equal. Therefore, when overriding equals(), you should also override hashCode() to ensure consistency and symmetry.
    because HashSet, HashMap, and Hashtable rely on the hashCode() method.

3.  Explain SYNCHRONIZE and VOLATILE keyword
    SYNCHRONIZE ensures that only one thread can execute the synchronized block or method at any given time, preventing race conditions and ensuring thread safety.
    VOLATILE meaning a variables value may be modified by different threads. its value will always be read from and written to main memory, ensuring visibility of changes
    across threads.
    They address different aspects of concurrency control and are used in different scenarios depending on the requirements of the application.

4. Difference between collection and stream
5. expain MAP and REDUCE method from streams.
    Important Points/Observations of Java Stream
    1. A stream consists of a source followed by zero or more intermediate methods combined together and a terminal method to process the objects obtained from the source.
    2. Stream is used to compute elements as per the pipelined methods without altering the original value of the object.

    MAP : it is used to transform each element of a stream into another element. 
    example : List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
              List<Integer> squaredNumbers = numbers.stream()
                                     .map(n -> n * n)
                                     .collect(Collectors.toList());
              System.out.println(squaredNumbers); // Output: [1, 4, 9, 16, 25]

    REDUCE : it is used to reduce the elements of a stream to a single value. It takes two parameters: an identity value and a BinaryOperator. The identity value is the 
             initial value for the reduction operation, and the BinaryOperator specifies how two elements should be combined.    
            It returns an Optional since the stream might be empty.
    example: List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
             Optional<Integer> sum = numbers.stream()
                               .reduce((a, b) -> a + b);
            sum.ifPresent(System.out::println); // Output: 15

6. Program denoting map(), filterr(), sorted(), collect(), forEach() and reduce()  methods of Stream API. (MaFi SorCore For)
    // create a list of integers
        List<Integer> number = Arrays.asList(2, 3, 4, 5); 
 
        // demonstration of map method
        List<Integer> square 
          = number.stream()
            .map(x -> x * x)
            .collect(Collectors.toList());
 
        // create a list of String
        List<String> names = Arrays.asList(
            "Reflection", "Collection", "Stream");
 
        // demonstration of filter method
        List<String> result
          = names.stream()
            .filter(s -> s.startsWith("S"))
            .collect(Collectors.toList());
       
        System.out.println(result);
 
        // demonstration of sorted method
        List<String> show 
          = names.stream()
            .sorted()
            .collect(Collectors.toList());
       
        System.out.println(show);
 
        // create a list of integers
        List<Integer> numbers
            = Arrays.asList(2, 3, 4, 5, 2);
 
        // collect method returns a set
        Set<Integer> squareSet
          = numbers.stream()
            .map(x -> x * x)
            .collect(Collectors.toSet());
       
        System.out.println(squareSet);
 
        // demonstration of forEach method
        number.stream()
            .map(x -> x * x)
            .forEach(y -> System.out.println(y));
 
        // demonstration of reduce method
        int even 
          = number.stream()
            .filter(x -> x % 2 == 0)
            .reduce(0, (ans, i) -> ans + i);
 
        System.out.println(even);
    }
    

7. What is functional programming
8. what do you mean by orchestrate in microservices
    orchestration" refers to the coordination and management of multiple microservices to achieve a specific business goal or process. Orchestration involves controlling
    the flow of data and requests between different microservices, ensuring that they work together harmoniously to fulfill complex functionalities or workflows.
    Common orchestration tools and frameworks used in microservices architectures include Kubernetes, Docker Swarm, Apache Mesos, and cloud-native platforms like 
    AWS ECS (Elastic Container Service) and Azure Kubernetes Service (AKS).

9. serialVersionUID", This variable is used in serialization to ensure that the version of the class being deserialized matches the version of the class
    that was serialized. If the serialVersionUID of the serialized object does not match the serialVersionUID of the class at the time of deserialization, then
    an InvalidClassException is thrown. It serves as a version control mechanism for serialized objects. It's a unique identifier for each class that implements 
    the Serializable interface. By explicitly declaring the serialVersionUID in the code, you can control the serialization version of the class, ensuring 
    compatibility between different versions of the class. The value "1L" is simply an arbitrary identifier for the first version of the class. If you make changes to
    the class that affect its serialization compatibility, you would typically increment this value to indicate a new version.
    
9. A stored procedure is a set of SQL statements that can be stored in the database and executed as a single unit. Stored procedures are used to encapsulate 
    repetitive tasks, complex logic, or frequently executed queries, and can be invoked by applications, scripts, or even other stored procedures
        example: 
            CREATE PROCEDURE GetCustomerList
            AS
            BEGIN
                SELECT CustomerID, FirstName, LastName, Email
                FROM Customers
                ORDER BY LastName, FirstName;
           END;


    To execute this stored procedure, you would use the following SQL command: EXEC GetCustomerList;

10. what is @qualifier 
      In the Java Spring Framework, @Qualifier is an annotation used to resolve the ambiguity between
      multiple beans of the same type. It helps specify which bean should be injected when there are multiple candidates.
    Example:
        @Autowired
        @Qualifier("specificBean")
        private MyService myService;

11. how to add custom methods to string class
        In Java, you cannot directly add methods to existing classes such as String because it is a final class. However, you can achieve similar functionality by
        creating a utility class with static methods that operate on String objects. This approach is common in Java for extending the functionality of built-in classes.

                        public class StringUtils {
                            // Custom method to reverse a string
                            public static String reverse(String str) {
                                return new StringBuilder(str).reverse().toString();
                            }
                        
                            // Custom method to check if a string is a palindrome
                            public static boolean isPalindrome(String str) {
                                String reversed = reverse(str);
                                return str.equals(reversed);
                            }

                            // Custom method to capitalize the first letter of each word in a string
                            public static String capitalizeWords(String str) {
                                String[] words = str.split("\\s+");
                                StringBuilder capitalized = new StringBuilder();
                                
                                for (String word : words) {
                                    if (word.length() > 0) {
                                        capitalized.append(Character.toUpperCase(word.charAt(0)))
                                                   .append(word.substring(1).toLowerCase())
                                                   .append(" ");
                                    }
                                }
                                
                                return capitalized.toString().trim();
                          

                Using the Custom Methods. You can now use the methods defined in the StringUtils class to perform operations on String objects.
                    public class Main {
                            public static void main(String[] args) {
                                String original = "hello world";
                                
                                // Reverse the string
                                String reversed = StringUtils.reverse(original);
                                System.out.println("Reversed: " + reversed); // Output: "dlrow olleh"
                                
                                // Check if the string is a palindrome
                                boolean isPalindrome = StringUtils.isPalindrome("madam");
                                System.out.println("Is palindrome: " + isPalindrome); // Output: true
                                
                                // Capitalize the first letter of each word
                                String capitalized = StringUtils.capitalizeWords(original);
                                System.out.println("Capitalized: " + capitalized); // Output: "Hello World"


12. how many ways to create objects 
     1. Using reflection
         example:  MyClass obj = (MyClass) Class.forName("MyClass").newInstance();
     2. Using clone() method
         example: MyClass obj1 = new MyClass();
                  MyClass obj2 = (MyClass) obj1.clone();
     3. Using factory methods
          example: MyClass obj = MyClassFactory.createMyClass();
     4. Using deserialization
          example: ObjectInputStream in = new ObjectInputStream(new FileInputStream("file.ser"));
                   MyClass obj = (MyClass) in.readObject();
     5. Using dependency injection frameworks (like Spring)
           example: ApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");
                    MyClass obj = (MyClass) context.getBean("myClass");


13. which data type used to stop a thread.  ans boolean 
14. how to create mockito mock object for database
15. what is point cut
16. what is reflection
        Reflection is found in Java Reflection API, which allows programs to inspect and manipulate the runtime behavior of applications. you can modify
        the structure and properties of classes, methods, and fields, Constructors, Annotations at runtime, even if they are private. This capability is particularly
        useful for tasks like debugging, testing, and building frameworks or libraries that need to operate on classes dynamically.

                                    import java.lang.reflect.Field;

                                                class Person {
                                                    private String name;
                                                    private int age;
                                                
                                                    public Person(String name, int age) {
                                                        this.name = name;
                                                        this.age = age;
                                                    }
                                                
                                                    // Getters
                                                    public String getName() {
                                                        return name;
                                                    }
                                                
                                                    public int getAge() {
                                                        return age;
                                                    }
                                                }
                                                
                                                public class Main {
                                                    public static void main(String[] args) {
                                                        try {
                                                            Person person = new Person("John", 30);
                                                
                                                            // Get the Class object
                                                            Class<?> personClass = person.getClass();
                                                
                                                            // Access and modify the private field 'name'
                                                            Field nameField = personClass.getDeclaredField("name");
                                                            nameField.setAccessible(true); // Make the private field accessible
                                                            System.out.println("Original Name: " + nameField.get(person)); // Output: John
                                                            nameField.set(person, "Jane");
                                                            System.out.println("Modified Name: " + nameField.get(person)); // Output: Jane
                                                
                                                            // Access and modify the private field 'age'
                                                            Field ageField = personClass.getDeclaredField("age");
                                                            ageField.setAccessible(true);
                                                            System.out.println("Original Age: " + ageField.get(person)); // Output: 30
                                                            ageField.setInt(person, 25);
                                                            System.out.println("Modified Age: " + ageField.get(person)); // Output: 25
                                                
                                                        } catch (NoSuchFieldException | IllegalAccessException e) {
                                                            e.printStackTrace();




17. Learn design patterns
28. Singleton design pattern. example 
29. what is aggregation and association
30. steps to deploy microservices 
    1. Prepare Your Application
        writing unit and integration tests. 
        Using a build tool like Maven or Gradle to manage dependencies and build the project.
    2. Choose Your Deployment Environment
        Cloud Providers: AWS, Google Cloud Platform, Azure, etc.
        On-Premise Servers
    3. Containerize Your Application
        Containerization helps in packaging your microservices along with all their dependencies to ensure consistency across environments.
        Docker is the most popular tool for this purpose.
    4. Push to a Container Registry
        Push your Docker image to a container registry like Docker Hub, AWS ECR, Google Container Registry, etc.
    5. Set Up Your Infrastructure
        Depending on your deployment environment, set up the necessary infrastructure.
        Create a Kubernetes Cluster: You can use managed Kubernetes services like GKE (Google Kubernetes Engine), EKS (Elastic Kubernetes Service), 
        or AKS (Azure Kubernetes Service). 
        Create Deployment and Service YAML files:
    6. Deploy to Kubernetes
        kubectl apply -f deployment.yaml
        kubectl apply -f service.yaml

    7. Configure Monitoring and Logging. Tools you can use:
            Prometheus and Grafana: For monitoring.
            ELK Stack (Elasticsearch, Logstash, Kibana): For logging.
            Jaeger or Zipkin: For distributed tracing
    8. Set Up CI/CD Pipeline
        Automate the build, test, and deployment process using a CI/CD pipeline.
        CI/CD Tools: Jenkins, GitLab CI, GitHub Actions, CircleCI, etc.
        Pipeline Example (Jenkinsfile):
    9. Post-Deployment Steps
        Health Checks: Ensure the services are running correctly.
        Scaling: Adjust the number of replicas based on the load.
        Security: Set up security measures like network policies, secrets management, etc.

31. steps to create microservices 
    1. Create a Spring Boot Project
    2. Create Your First Microservice
        └── src
        ├── main
        │   ├── java
        │   │   └── com.example.microservice
        │   │       ├── MicroserviceApplication.java
        │   │       ├── controller
        │   │       ├── service
        │   │       └── repository
        │   └── resources
        │       ├── application.properties
        └── test

        Run the Application:
    3. Add More Microservices : Repeat the steps to create additional microservices. Each microservice should be a separate Spring Boot project.
    4. Configure Communication Between Microservices : Microservices often need to communicate with each other. You can use REST, messaging queues, or
        service discovery for this.
        1. Using REST: RestTemplate, Feign Client: A declarative REST client.
        2. Service Discovery with Eureka: Add Dependencies -> Create a Eureka Server -> Register Microservices with Eureka -> Configure application.properties ->
            Use Eureka Discovery for Inter-Service Communication.

    5. Database Configuration : If each microservice has its own database, configure the application.properties or application.yml for database connectivity
    6. Secure Your Microservices
    7. Deploy and Monitor


32. what is dynamic dispatch 
    Dynamic dispatch, also known as dynamic method dispatch or runtime polymorphism, is a mechanism by which a call to an overridden method is resolved at
    runtime rather than at compile-time. 
    How Dynamic Dispatch Works ?
    When a method is called on an object, the Java Virtual Machine (JVM) determines the actual method to execute based on the runtime type of the object,
    not the reference type. This enables the correct method to be called even when the reference type is of a superclass.
