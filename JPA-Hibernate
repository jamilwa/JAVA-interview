1. What is Hibernate?

Answer:
Hibernate is a Java-based ORM (Object-Relational Mapping) framework that maps Java objects to relational database tables. It eliminates most JDBC boilerplate code and automates CRUD operations.

2. What is JPA?

Answer:
JPA (Java Persistence API) is a standard specification for object-relational mapping in Java. It defines interfaces and annotations for persisting data, but it alone doesnâ€™t implement these behaviors; Hibernate is one of the most common JPA providers.

3. Whatâ€™s the difference between JPA and Hibernate?

Answer:

JPA: A specification/API defining how ORM should work.

Hibernate: A concrete implementation of JPA that adds additional features like caching, better query handling, advanced mapping strategies, etc.

4. What are advantages of using Hibernate?

Answer:

Eliminates JDBC boilerplate

Provides HQL (object-oriented query language)

Caching support

Database independence

Automatic transaction & session management

5. What is ORM?

Answer:
ORM stands for Object-Relational Mapping â€” it converts Java objects to database tables and vice versa, so developers work with objects rather than SQL, reducing manual syntax and errors.

6. Difference between Hibernate and JDBC?

Answer:

JDBC requires manual SQL and result-set mapping.

Hibernate abstracts this via ORM and manages entity states, caching, and transactions automatically.

7. What is HQL?

Answer:
Hibernate Query Language (HQL) is an object-oriented query language similar to SQL but works with object entities and their properties instead of tables and columns.

8. What are EntityManager and Session?

Answer:

EntityManager (JPA): Standard interface to interact with persistence context.

Session (Hibernate): Similar to EntityManager, but specific to Hibernate and has additional methods like save(), saveOrUpdate() etc.

9. Difference between persist() and save()?

Answer:

persist() (JPA): Makes entity managed but doesnâ€™t return primary key.

save() (Hibernate): Persists entity and returns generated ID.

10. What is the difference between get() and load() in Hibernate?

Answer:

get(): Eagerly fetches the object; returns null if not found.

load(): Lazily fetches; returns a proxy object and throws an exception if entity doesnâ€™t exist when accessed.

11. What are the states of a JPA entity?

Answer:

Transient: Not associated with persistence context

Persistent: Tracked by the context

Detached: Was persistent but no longer tracked (e.g., after session close)

12. How is inheritance mapped in Hibernate?

Answer:
Hibernate supports:

SINGLE_TABLE â€“ maps entire hierarchy into one table

TABLE_PER_CLASS â€“ each class gets its own table

JOINED â€“ parent and child in separate tables linked by keys

13. How do you define relationships in JPA/Hibernate?

Answer:

@OneToOne â€“ single entity to single entity

@OneToMany, @ManyToOne â€“ one parent to multiple children

@ManyToMany â€“ many â†” many
These are mapped with annotations and often combined with @JoinColumn or @JoinTable.

14. What is caching in Hibernate?

Answer:

First-level cache: Provided by default within a session.

Second-level cache: Shared cache across sessions that improves performance.

15. What are common JPA annotations?

Answer:

@Entity, @Table, @Id, @GeneratedValue

@Column, @OneToMany, @ManyToOne, etc.
These help define entity mapping and relationships.

16. How do you run native SQL in JPA?

Answer:
Use EntityManager.createNativeQuery() or @NamedNativeQuery to execute raw SQL directly.

17. What is a Criteria Query?

Answer:
A type-safe, programmatic way to build queries in JPA (alternative to JPQL strings). It supports dynamic query composition.

18. How is transaction managed in JPA?

Answer:
With EntityTransaction (begin, commit, rollback) via EntityManager, or using @Transactional in Spring for declarative transactions.

ðŸ“Œ Tips for Interviews

Always clarify whether the question is about JPA specification, Hibernate implementation, or Spring Data JPA â€” they are related but different.

Be ready to explain how lazy loading and fetch types impact performance and how caching works.

18. Question: What is the N+1 problem and how can you fix it?
Answer:
The N+1 SELECT problem happens when Hibernate executes one query for the parent entities and then, for each parent, one additional query for child entities â€” leading to N+1 total queries, causing severe performance issues.

Example & Fix â€” Using JOIN FETCH:

String hql = "SELECT d FROM Department d " +
             "JOIN FETCH d.employees WHERE d.id = :id";
Department dept = session.createQuery(hql, Department.class)
                         .setParameter("id", deptId)
                         .uniqueResult();


ðŸ“Œ Using JOIN FETCH loads departments and employees in a single query, preventing extra queries.

19. Question: What is optimistic locking and how do you implement it?
Answer:
Optimistic locking detects concurrent updates without locking rows. It uses a version column annotated with @Version. When two transactions try to update the same entity version, the second update fails, preventing lost updates.

Entity Example:

@Entity
public class Product {
    @Id
    @GeneratedValue
    private Long id;

    @Version
    private Integer version;

    private String name;
    // getters/setters
}


Usage:
When you fetch and update a Product, the version field ensures updates are only accepted if no one else modified it in the meantime.

20. 
