1. What is Hibernate?

Answer:
Hibernate is a Java-based ORM (Object-Relational Mapping) framework that maps Java objects to relational database tables. It eliminates most JDBC boilerplate code and automates CRUD operations.

2. What is JPA?

Answer:
JPA (Java Persistence API) is a standard specification for object-relational mapping in Java. It defines interfaces and annotations for persisting data, but it alone doesnâ€™t implement these behaviors; Hibernate is one of the most common JPA providers.

3. Whatâ€™s the difference between JPA and Hibernate?

Answer:

JPA: A specification/API defining how ORM should work.

Hibernate: A concrete implementation of JPA that adds additional features like caching, better query handling, advanced mapping strategies, etc.

4. What are advantages of using Hibernate?

Answer:

Eliminates JDBC boilerplate

Provides HQL (object-oriented query language)

Caching support

Database independence

Automatic transaction & session management

5. What is ORM?

Answer:
ORM stands for Object-Relational Mapping â€” it converts Java objects to database tables and vice versa, so developers work with objects rather than SQL, reducing manual syntax and errors.

6. Difference between Hibernate and JDBC?

Answer:

JDBC requires manual SQL and result-set mapping.

Hibernate abstracts this via ORM and manages entity states, caching, and transactions automatically.

7. What is HQL?

Answer:
Hibernate Query Language (HQL) is an object-oriented query language similar to SQL but works with object entities and their properties instead of tables and columns.

8. What are EntityManager and Session?

Answer:

EntityManager (JPA): Standard interface to interact with persistence context.

Session (Hibernate): Similar to EntityManager, but specific to Hibernate and has additional methods like save(), saveOrUpdate() etc.

9. Difference between persist() and save()?

Answer:

persist() (JPA): Makes entity managed but doesnâ€™t return primary key.

save() (Hibernate): Persists entity and returns generated ID.

10. What is the difference between get() and load() in Hibernate?

Answer:

get(): Eagerly fetches the object; returns null if not found.

load(): Lazily fetches; returns a proxy object and throws an exception if entity doesnâ€™t exist when accessed.

11. What are the states of a JPA entity?

Answer:

Transient: Not associated with persistence context

Persistent: Tracked by the context

Detached: Was persistent but no longer tracked (e.g., after session close)

12. How is inheritance mapped in Hibernate?

Answer:
Hibernate supports:

SINGLE_TABLE â€“ maps entire hierarchy into one table

TABLE_PER_CLASS â€“ each class gets its own table

JOINED â€“ parent and child in separate tables linked by keys

13. How do you define relationships in JPA/Hibernate?

Answer:

@OneToOne â€“ single entity to single entity

@OneToMany, @ManyToOne â€“ one parent to multiple children

@ManyToMany â€“ many â†” many
These are mapped with annotations and often combined with @JoinColumn or @JoinTable.

14. What is caching in Hibernate?

Answer:

First-level cache: Provided by default within a session.

Second-level cache: Shared cache across sessions that improves performance.

15. What are common JPA annotations?

Answer:

@Entity, @Table, @Id, @GeneratedValue

@Column, @OneToMany, @ManyToOne, etc.
These help define entity mapping and relationships.

16. How do you run native SQL in JPA?

Answer:
Use EntityManager.createNativeQuery() or @NamedNativeQuery to execute raw SQL directly.

17. What is a Criteria Query?

Answer:
A type-safe, programmatic way to build queries in JPA (alternative to JPQL strings). It supports dynamic query composition.

18. How is transaction managed in JPA?

Answer:
With EntityTransaction (begin, commit, rollback) via EntityManager, or using @Transactional in Spring for declarative transactions.

ðŸ“Œ Tips for Interviews

Always clarify whether the question is about JPA specification, Hibernate implementation, or Spring Data JPA â€” they are related but different.

Be ready to explain how lazy loading and fetch types impact performance and how caching works.

18. Question: What is the N+1 problem and how can you fix it?
Answer:
The N+1 SELECT problem happens when Hibernate executes one query for the parent entities and then, for each parent, one additional query for child entities â€” leading to N+1 total queries, causing severe performance issues.

Example & Fix â€” Using JOIN FETCH:

String hql = "SELECT d FROM Department d " +
             "JOIN FETCH d.employees WHERE d.id = :id";
Department dept = session.createQuery(hql, Department.class)
                         .setParameter("id", deptId)
                         .uniqueResult();


ðŸ“Œ Using JOIN FETCH loads departments and employees in a single query, preventing extra queries.

19. Question: What is optimistic locking and how do you implement it?
Answer:
Optimistic locking detects concurrent updates without locking rows. It uses a version column annotated with @Version. When two transactions try to update the same entity version, the second update fails, preventing lost updates.

Entity Example:

@Entity
public class Product {
    @Id
    @GeneratedValue
    private Long id;

    @Version
    private Integer version;

    private String name;
    // getters/setters
}


Usage:
When you fetch and update a Product, the version field ensures updates are only accepted if no one else modified it in the meantime.

20. How do you handle composite primary keys in JPA?
Answer:
Use @Embeddable for the composite key class and @EmbeddedId in the entity.

Code Example:

@Embeddable
public class OrderId implements Serializable {
    private Long customerId;
    private Long orderId;
}

@Entity
public class Order {
    @EmbeddedId
    private OrderId id;

    private String product;
}


This maps a primary key made of multiple fields.

21. Question: How would you implement a many-to-many relationship?
Answer:
Use @ManyToMany and a join table.

@Entity
public class Student {
    @Id
    @GeneratedValue
    private Long id;

    @ManyToMany
    @JoinTable(name = "student_course",
        joinColumns = @JoinColumn(name = "student_id"),
        inverseJoinColumns = @JoinColumn(name = "course_id"))
    private Set<Course> courses = new HashSet<>();
}

@Entity
public class Course {
    @Id
    @GeneratedValue
    private Long id;

    @ManyToMany(mappedBy = "courses")
    private Set<Student> students = new HashSet<>();
}


This creates a join table to link students and courses.

22. Question: What are default fetch types for associations?
Answer:

@ManyToOne and @OneToOne â†’ EAGER

@OneToMany and @ManyToMany â†’ LAZY
Best practice is to explicitly set fetch types to avoid performance issues.

Example:

@OneToMany(fetch = FetchType.LAZY)
private List<Order> orders;


Use lazy loading for large collections to avoid loading unnecessary data.

23. Explain automatic dirty checking.
Answer:
Hibernate automatically detects changes to managed entities and flushes them at commit without explicit update(). Example:

Employee emp = session.get(Employee.class, 1L);
emp.setAge(31);
session.getTransaction().commit();


Hibernate generates appropriate SQL because it tracked the modified field.

24. 
