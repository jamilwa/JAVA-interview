1. API Gateway Pattern
         In microservices, clients may need to communicate with multiple services (e.g., User, Order, Product). Exposing all services directly can cause:
            1. Tight Coupling: Clients must know the location and details of every microservice.
            2. Repeated Effort: Concerns like authentication, rate-limiting, and logging are repeated in every service.
         The API Gateway acts as a single entry point that aggregates and routes requests to the relevant microservices while handling common concerns.
   Using Spring Cloud Gateway as the API Gateway.
   pom.xml
       <artifactId>spring-cloud-starter-gateway</artifactId>
      <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>

main.java      
   @SpringBootApplication
   @EnableDiscoveryClient
   public class ApiGatewayApplication {
      public static void main(String[] args) {
        SpringApplication.run(ApiGatewayApplication.class, args);
      }
    }


application.yml
server:
  port: 8080

spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://USER-SERVICE
          predicates:
            - Path=/users/**
        - id: order-service
          uri: lb://ORDER-SERVICE
          predicates:
            - Path=/orders/**
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/



2. Circuit Breaker Pattern
Why Use Circuit Breakers?
To prevent cascading failures when one service becomes unresponsive.
Circuit breakers monitor service calls and "open" to block traffic when failure rates are high.
Using Resilience4j for circuit breaker functionality.

pom.xml
    <dependency>
      <groupId>io.github.resilience4j</groupId>
      <artifactId>resilience4j-spring-boot2</artifactId>
      <version>1.7.1</version>
    </dependency>


OrderService.java
@Service
public class OrderService {
    @Autowired
    private RestTemplate restTemplate;

    @CircuitBreaker(name = "userService", fallbackMethod = "userServiceFallback")
    public String getUserData() {
        return restTemplate.getForObject("http://localhost:8081/users", String.class);
    }

    public String userServiceFallback(Exception e) {
        return "User Service is currently unavailable. Please try again later.";
    }
}


application.yml
  resilience4j:
    circuitbreaker:
      configs:
        default:
          failure-rate-threshold: 50
          wait-duration-in-open-state: 5000ms
      instances:
        userService:
          base-config: default



3. Service Registry and Discovery Pattern
Using Eureka Server for service registry and discovery.

  pom.xml
    <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
    </dependency>


  EurekaServerApplication.java
              @SpringBootApplication
              @EnableEurekaServer
              public class EurekaServerApplication {
                  public static void main(String[] args) {
                  SpringApplication.run(EurekaServerApplication.class, args);
                }
              }


  application.yml
    server:
      port: 8761

    eureka:
      client:
        register-with-eureka: false
        fetch-registry: false


Registering Services
Add the following dependency to both User and Order services:
          <dependency>
              <groupId>org.springframework.cloud</groupId>
              <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
          </dependency>



application.yml
        eureka:
          client:
            service-url:
              defaultZone: http://localhost:8761/eureka/

    

4. Database per Service Pattern
Why Separate Databases?
         Microservices are loosely coupled, and sharing a database violates that principle. Different services have different data storage requirements.
Solution: One database per microservice must be designed. It must be private to that service only, and it should be accessed by the microservice API only.
         It cannot be accessed by other services directly. It helps to address below concerns like
         Scalability (services can scale independently).
         Failure isolation (issues in one database don’t affect others).
         Some business transactions need to query data that is owned by multiple services.

5. Command Query Responsibility Segregation (CQRS)
         Once we implement database-per-service, there is a requirement to query, which requires joint data from multiple services — it's not possible.
Solution: CQRS suggests splitting the application into two parts — the command side and the query side. The command side handles the Create, Update, and Delete requests.
          The query side handles the query component by using materialized views. The event sourcing design pattern is generally used along with it to create events for
          any data change. As such, materialized views are kept up to date by subscribing to the stream of events.

6. Saga Pattern
Problem : When each service has its own database and a business transaction spans multiple services, how do we ensure data consistency across services? 
         For example, for an e-commerce application where customers have a credit limit, the application must ensure that a new order will not exceed the customer’s
         credit limit. Since Orders and Customers are in different databases, the application cannot simply use a local ACID transaction.
Solution : A Saga represents a high-level business process that consists of several sub-requests, which each update data within a single service. 
         Each request has a compensating request that is executed when the request fails. It can be implemented in two ways:
         1. Choreography – When there is no central coordination, each service produces and listens to another service’s events and decides if an action should be
                           taken or not.
         2. Orchestration – An orchestrator (object) takes responsibility for a saga’s decision-making and sequencing business logic.


7.  Event-Driven Pattern
Why Use Event-Driven Architecture?
Decouples services by using asynchronous communication.
Services do not directly call each other; instead, they publish or subscribe to events using a message broker (e.g., RabbitMQ, Kafka).
Improves system resilience and scalability.


8. Log Aggregation
   Problem: Consider a use case where an application consists of multiple service instances that are running on multiple machines. Requests often span multiple
         service instances. Each service instance generates a log file in a standardized format. How can we understand the application behavior through logs for a 
         particular request?
   Solution : We need a centralized logging service that aggregates logs from each service instance. Users can search and analyze the logs. They can configure alerts
              that are triggered when certain messages appear in the logs. For example, PCF does have Loggeregator, which collects logs from each component
              (router, controller, diego, etc...) of the PCF platform along with applications. AWS Cloud Watch also does the same.

