1. API Gateway Pattern
         In microservices, clients may need to communicate with multiple services (e.g., User, Order, Product). Exposing all services directly can cause:
            1. Tight Coupling: Clients must know the location and details of every microservice.
            2. Repeated Effort: Concerns like authentication, rate-limiting, and logging are repeated in every service.
         The API Gateway acts as a single entry point that aggregates and routes requests to the relevant microservices while handling common concerns.
   Using Spring Cloud Gateway as the API Gateway.
   pom.xml
       <artifactId>spring-cloud-starter-gateway</artifactId>
      <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>

main.java      
   @SpringBootApplication
   @EnableDiscoveryClient
   public class ApiGatewayApplication {
      public static void main(String[] args) {
        SpringApplication.run(ApiGatewayApplication.class, args);
      }
    }


application.yml
server:
  port: 8080

spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://USER-SERVICE
          predicates:
            - Path=/users/**
        - id: order-service
          uri: lb://ORDER-SERVICE
          predicates:
            - Path=/orders/**
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/



2. Circuit Breaker Pattern
Why Use Circuit Breakers?
To prevent cascading failures when one service becomes unresponsive.
Circuit breakers monitor service calls and "open" to block traffic when failure rates are high.
Using Resilience4j for circuit breaker functionality.

pom.xml
    <dependency>
      <groupId>io.github.resilience4j</groupId>
      <artifactId>resilience4j-spring-boot2</artifactId>
      <version>1.7.1</version>
    </dependency>


OrderService.java
@Service
public class OrderService {
    @Autowired
    private RestTemplate restTemplate;

    @CircuitBreaker(name = "userService", fallbackMethod = "userServiceFallback")
    public String getUserData() {
        return restTemplate.getForObject("http://localhost:8081/users", String.class);
    }

    public String userServiceFallback(Exception e) {
        return "User Service is currently unavailable. Please try again later.";
    }
}


application.yml
  resilience4j:
    circuitbreaker:
      configs:
        default:
          failure-rate-threshold: 50
          wait-duration-in-open-state: 5000ms
      instances:
        userService:
          base-config: default



3. Service Registry and Discovery Pattern
Using Eureka Server for service registry and discovery.

  pom.xml
    <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
    </dependency>


  EurekaServerApplication.java
              @SpringBootApplication
              @EnableEurekaServer
              public class EurekaServerApplication {
                  public static void main(String[] args) {
                  SpringApplication.run(EurekaServerApplication.class, args);
                }
              }


  application.yml
    server:
      port: 8761

    eureka:
      client:
        register-with-eureka: false
        fetch-registry: false


Registering Services
Add the following dependency to both User and Order services:
          <dependency>
              <groupId>org.springframework.cloud</groupId>
              <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
          </dependency>



application.yml
        eureka:
          client:
            service-url:
              defaultZone: http://localhost:8761/eureka/

    

4. Database per Service Pattern
Why Separate Databases?
         Microservices are loosely coupled, and sharing a database violates that principle. Different services have different data storage requirements.
Solution: One database per microservice must be designed. It must be private to that service only, and it should be accessed by the microservice API only.
         It cannot be accessed by other services directly. It helps to address below concerns like
         Scalability (services can scale independently).
         Failure isolation (issues in one database don’t affect others).
         Some business transactions need to query data that is owned by multiple services.

5. Command Query Responsibility Segregation (CQRS)
         Once we implement database-per-service, there is a requirement to query, which requires joint data from multiple services — it's not possible.
Solution: CQRS suggests splitting the application into two parts — the command side and the query side. The command side handles the Create, Update, and Delete requests.
          The query side handles the query component by using materialized views. The event sourcing design pattern is generally used along with it to create events for
          any data change. As such, materialized views are kept up to date by subscribing to the stream of events.


6.  Event-Driven Pattern
Why Use Event-Driven Architecture?
Decouples services by using asynchronous communication.
Services do not directly call each other; instead, they publish or subscribe to events using a message broker (e.g., RabbitMQ, Kafka).
Improves system resilience and scalability.

7. 
