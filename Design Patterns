1. API Gateway Pattern
         In microservices, clients may need to communicate with multiple services (e.g., User, Order, Product). Exposing all services directly can cause:
            1. Tight Coupling: Clients must know the location and details of every microservice.
            2. Repeated Effort: Concerns like authentication, rate-limiting, and logging are repeated in every service.
         The API Gateway acts as a single entry point that aggregates and routes requests to the relevant microservices while handling common concerns.
   Using Spring Cloud Gateway as the API Gateway.
   pom.xml
       <artifactId>spring-cloud-starter-gateway</artifactId>
      <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>

main.java      
   @SpringBootApplication
   @EnableDiscoveryClient
   public class ApiGatewayApplication {
      public static void main(String[] args) {
        SpringApplication.run(ApiGatewayApplication.class, args);
      }
    }


application.yml
server:
  port: 8080

spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://USER-SERVICE
          predicates:
            - Path=/users/**
        - id: order-service
          uri: lb://ORDER-SERVICE
          predicates:
            - Path=/orders/**
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/



2. Circuit Breaker Pattern
Why Use Circuit Breakers?
To prevent cascading failures when one service becomes unresponsive.
Circuit breakers monitor service calls and "open" to block traffic when failure rates are high.
Using Resilience4j for circuit breaker functionality.

pom.xml
    <dependency>
      <groupId>io.github.resilience4j</groupId>
      <artifactId>resilience4j-spring-boot2</artifactId>
      <version>1.7.1</version>
    </dependency>


OrderService.java
@Service
public class OrderService {
    @Autowired
    private RestTemplate restTemplate;

    @CircuitBreaker(name = "userService", fallbackMethod = "userServiceFallback")
    public String getUserData() {
        return restTemplate.getForObject("http://localhost:8081/users", String.class);
    }

    public String userServiceFallback(Exception e) {
        return "User Service is currently unavailable. Please try again later.";
    }
}


application.yml
  resilience4j:
    circuitbreaker:
      configs:
        default:
          failure-rate-threshold: 50
          wait-duration-in-open-state: 5000ms
      instances:
        userService:
          base-config: default



3. Service Registry and Discovery Pattern
Using Eureka Server for service registry and discovery.

  pom.xml
    <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
    </dependency>


  EurekaServerApplication.java
              @SpringBootApplication
              @EnableEurekaServer
              public class EurekaServerApplication {
                  public static void main(String[] args) {
                  SpringApplication.run(EurekaServerApplication.class, args);
                }
              }


  application.yml
    server:
      port: 8761

    eureka:
      client:
        register-with-eureka: false
        fetch-registry: false


Registering Services
Add the following dependency to both User and Order services:
          <dependency>
              <groupId>org.springframework.cloud</groupId>
              <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
          </dependency>



application.yml
        eureka:
          client:
            service-url:
              defaultZone: http://localhost:8761/eureka/

    

4. Database per Service Pattern
Why Separate Databases?
Microservices are loosely coupled, and sharing a database violates that principle.
Independent databases ensure:
Scalability (services can scale independently).
Data autonomy (each service owns its schema).
Failure isolation (issues in one database donâ€™t affect others).
Each microservice manages its own database schema and operations


5.  Event-Driven Pattern
Why Use Event-Driven Architecture?
Decouples services by using asynchronous communication.
Services do not directly call each other; instead, they publish or subscribe to events using a message broker (e.g., RabbitMQ, Kafka).
Improves system resilience and scalability.

