1.                  Array                                                                          Arraylist 
    Array is static in size.	                                                	ArrayList is dynamic in size.
    It is mandatory to provide the size of an array while using new keyword     	We can create an instance of ArrayList without specifying its size. 
     ex:   int[] myArray = new int[6];                                              	 initial capacity is 10.
           myArray[0] = 3;
    It performs fast because of fixed size.	                                		The resize operation slows down the performance.
    length variable to determine the size of an array.	                        	size() method to determine the size of ArrayList.
    stores both objects and primitives type.	                                	doesn't store primitive type. It automatically converts primitive type to object.
    can add elements in an array by using the assignment operator.	        		the add() method to add elements in the ArrayList.
    throws ArrayIndexOutofBoundException											                  throws IndexOutofBoundException


2. Arrays class methods are    (ABCDES) ---- Array BinarySearch CopyOf DeepToString Equals Sort
int[] numbers = {1, 2, 3, 7, 4, 5};
 void       Arrays.sort(numbers);                          // Output: [1, 2, 3, 4, 5, 7]
               Arrays.sort(numbers[], Comparator.reverseOrder())           // Sorting the array in descending order. note: it works on object like Integer not on int.
               Arrays.sort(numbers, 3,5);                                 // sorts only numbers falling between fromIndex 3 and toIndex 5

int[] copy = Arrays.copyOf(numbers, 3);
               Arrays.toString(copy));                         // Output: [1, 2, 3]

 Arrays.binarySearch(numbers, 3);                  // output:  2 which is the index position of the value 3

3. Access modifiers
        Default (Package-Private): accessible only within its own package.    DOP
        Protected: accessible in subclasses of other packages.  ProSOP

4. How to make collection threadsafe
	1. Using Synchronized Collections : Java provides synchronized wrappers for collections through the Collections.synchronizedXXX methods like 
		Collections.synchronizedList(), Collections.synchronizedSet(), Collections.synchronizedMap.
    examplee:   
    	List<Integer> list = Collections.synchronizedList(new ArrayList<>());

  2. Using Concurrent Collections : Java provides a set of concurrent collections in the java.util.concurrent package. 
	example:
		ConcurrentHashMap: A thread-safe variant of HashMap that allows concurrent read and write operations.
		CopyOnWriteArrayList: A thread-safe variant of ArrayList where all mutative operations (like add, set, etc.) are implemented by making a fresh copy
					of the underlying array.
		ConcurrentSkipListSet: This is a thread-safe variant of NavigableSet that uses a skip list for its underlying data structure. It allows concurrent 
					access and maintains a sorted order.
		BlockingQueue: An interface that represents a thread-safe queue that supports operations that wait for the queue to become non-empty when retrieving 
					an element and wait for space to become available in the queue when storing an element.
	3. Using ThreadLocal : If you want to maintain a separate instance of a collection for each thread, you can use ThreadLocal. This is useful when you want to
				avoid contention between threads.

5. if we have Collection.SynchronizedMap() then why to use concurrentHashmap
	Collections.synchronizedMap(): Provides serial access, meaning only one thread can access the map at a time for read or write operations. This can lead to
				       increased waiting times and reduced performance when multiple threads are involved.
				       Supports null keys and values, depending on the underlying map implementation.
				       The iterator is fail-fast, meaning it throws a ConcurrentModificationException if the map is modified while iterating
				       Suitable for applications where data consistency is more critical than performance.
	ConcurrentHashMap: Allows multiple threads to read and write concurrently. It uses a segmented locking mechanism, which means that only a portion of the map
				is locked during write operations, allowing for higher throughput.
				Does not allow null keys or values, which helps avoid ambiguity in concurrent environments.
				The iterator is fail-safe, allowing modifications during iteration without throwing exceptions.
				Ideal for high-performance applications where multiple threads frequently read and write data.

6.   			                      ArrayList				              LinkedList

structure                uses a dynamic array	                uses a doubly linked list.
Access                   Fast (O1)				                    Slow (On)
Insert/Delete in middle  Slow (On)                            Faster  
Memory                   Low                                  High
Iteration                Fast because contiguous memory       Slower becuase scattered nodes in memory 

7. Comparator
class Employee {
    String name;
    int age;

    // add Constructor, setter, getter and tostring
}

class AgeComparator implements Comparator<Employee> {
    @Override
    public int compare(Employee e1, Employee e2) {
        return Integer.compare(e1.age, e2.age); // Compare by age
    }
}

class NameComparator implements Comparator<Employee> {
    @Override
    public int compare(Employee e1, Employee e2) {
        // Compare by name in lexicographical order
        return e1.name.compareTo(e2.name);
    }
}

public class Main {
    public static void main(String[] args) {
        List<Employee> employees = Arrays.asList(new Employee("Alice", 30), new Employee("Charlie", 35), new Employee("Bob", 25), new Employee("Bob", 20) );

        Collections.sort(employees, new NameComparator());     				// is used if there are no setters and getters, but only constructor is there.
		System.out.println(employees); 						// output [Alice (30), Bob (25), Bob (20), Charlie (35)]

        Collections.sort(employees, Comparator.comparing(Employee::getName)); 
		System.out.println(employees); 						// output [Alice (30), Bob (25), Bob (20), Charlie (35)]

        Collections.sort(employees, Comparator.comparing(Employee::getName).thenComparing(Employee::getAge));        
		System.out.println(employees); 						// output [Alice (30), Bob (20), Bob (25), Charlie (35)]

        Collections.sort(employees, Comparator.comparing(Employee::getName, Comparator.reverseOrder())
      .thenComparing(Employee::getAge, Comparator.reverseOrder())); 
		System.out.println(employees); 						// output [Charlie (35), Bob (25), Bob (20), Alice (30)]


	if Comparator is not to be used in Collections.sort() by name & then by age, then we can make use of below code to do sorting
	
	class EmployeeComparator implements Comparator<Employee> {
	 
	    @Override
	    public int compare(Employee e1, Employee e2)
	    {
		// 1st level comparison
	        int NameCompare = e1.getName().compareTo(e2.getName());
	        int AgeCompare = Integer.compare(e1.Age, e2.Age);
	 
	        // 2nd level comparison
	        return (NameCompare == 0) ? AgeCompare : NameCompare;
		}

		and in main class use below
		Collections.sort(employees, new EmployeeComparator());

8. What is Functional Programming
	a programming style that uses pure functions to solve problems. It emphasizes writing concise, readable code that's easier to maintain and Test. it eliminates
	the need of anonymous class and gives a functional programming capability to Java. 
	Lambda expressions are used to define implementation of a functional interface.

		Types of Functional Interfaces
	Java provides several built-in functional interfaces in the java.util.function package.
	1. Predicate : The Predicate interface is often used for filtering and matching conditions.
		Description: Represents a function that takes one argument and returns a boolean.
		Method: boolean test(T t)
		
		Example:  filter()
			Predicate<String> isEmpty = str -> str.isEmpty();
			System.out.println(isEmpty.test("")); // true

	2. Function
		Description: Represents a function that takes one argument and produces a result.
		Method: R apply(T t)
		
		Example: map, flatmpa,sorted, disticnt
			Function<String, Integer> stringLength = str -> str.length();
			System.out.println(stringLength.apply("Hello")); // 5

	3. Consumer
		Description: Represents an function that takes a one argument and returns no result. It is used for operations that consume data.
		Method: void accept(T t)
		
		Example:   forEach, Peek
			Consumer<String> print = str -> System.out.println(str);
			print.accept("Hello, World!"); // Prints: Hello, World!

	4. Supplier
		Description: Represents a supplier of results. It does not take any arguments and returns a result.
		Method: T get()

		Example:
			Supplier<String> supplier = () -> "Hello, Supplier!";
			System.out.println(supplier.get()); // Hello, Supplier!

	5. UnaryOperator
		Description: Represents a function that takes a single argument of type T and returns a result of the same type.
		Method: T apply(T t)

		Example:
			UnaryOperator<Integer> square = x -> x * x;
			System.out.println(square.apply(5)); // 25

	6. BinaryOperator
		Description: Represents a function that takes two arguments of the same type and returns a result of the same type.
		Method: T apply(T t1, T t2)

		Example:
			BinaryOperator<Integer> add = (a, b) -> a + b;
			System.out.println(add.apply(5, 10)); // 15

9.  A method reference can be used to point the following types of methods −
Static methods
Instance methods
Constructors using new operator (TreeSet::new)

10. Optional - Optional class is a container object that may or may not contain a value. It was introduced as part of the import java.util.Optional; package to help
		developers avoid NullPointerExceptions and to provide a more expressive way to handle optional values.

	Creating an Optional: -You can create an Optional instance in several ways:
	1. Empty Optional:  Optional<String> emptyOptional = Optional.empty();			// it creates an empty Optional instance, it does not contain a value
	2. Optional with a Non-null Value: Optional<String> nonNullOptional = Optional.of("Hello, World!");	// it creates an Optional with a non-null value. If the
															value is null, it throws a NullPointerException
	3. Optional that Allows Null Values:	Optional<String> nullableOptional = Optional.ofNullable(null); 		// it creates an Optional that can hold a value 
															that may be null. If the value is null, it creates 
															an empty Optional


	Common Methods of Optional  (Get IfOrElse MapIsFlat)
	1. isPresent(): Checks if a value is present.
		Optional<String> optional = Optional.of("Hello");
		if (optional.isPresent()) {
    			System.out.println(optional.get()); // Prints: Hello
		}
	
	2. ifPresent(Consumer<? super T> action): Executes the given action if a value is present.
		optional.ifPresent(value -> System.out.println(value)); // Prints: Hello

	3. get(): Returns the value if present; otherwise, it throws NoSuchElementException.
		String value = optional.get(); // Returns "Hello"

	4. orElse(T other): Returns the value if present; otherwise, returns the provided default value.
		String value = emptyOptional.orElse("Default Value"); // Returns "Default Value"

	5. orElseGet(Supplier<? extends T> other): Returns the value if present; otherwise, invokes the provided supplier and returns the result.
		String value = emptyOptional.orElseGet(() -> "Generated Value"); // Returns "Generated Value"

	6. orElseThrow(Supplier<? extends X> exceptionSupplier): Returns the value if present; otherwise, throws an exception created by the provided supplier.
		String value = emptyOptional.orElseThrow(() -> new IllegalArgumentException("Value is absent"));

	7. map(Function<? super T, ? extends U> mapper): If a value is present, applies the provided mapping function to it and returns an Optional describing the result.
		Optional<Integer> lengthOptional = optional.map(String::length); // Returns Optional[5]

	8. flatMap(Function<? super T, Optional<U>> mapper): Similar to map, but the mapping function must return an Optional
		Optional<String> optionalValue = Optional.of("Hello");
		Optional<Integer> lengthOptional = optionalValue.flatMap(value -> Optional.of(value.length())); // Returns Optional[5]


11. Collectors (Collectors Group Joining parti, toList counting summarizingInt) 
12. List of Terminal Operations in Streams (ColCouToA, ReSuMa, NoneAllAny, SummrayforEa)
13. why do we use IntStream
        the Stream API is designed to work with objects, not primitive types directly. However, the Stream API provides special primitive-type streams to handle
        primitive values such as 
        IntStream: A stream of primitive ints. 

	How do you create an IntStream in Java?
		IntStream.of(numbers[])
             or by converting other data structures like arrays or collections using
        Arrays.stream(int[] array) or 
        Collection.stream().mapToInt().

	the methods of InstStream are	sum, average, min, count, summaryStatistics
		example: int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
				 int sum = IntStream.of(numbers).sum();

example:   int[] intArray = {1, 2, 3, 4, 5};
           IntStream a = Arrays.stream(intArray);        // Using IntStream
           int sum = a.sum();           				// Example operations on IntStream
You can convert a regular Stream to a primitive-type stream using methods like mapToInt, mapToLong, or mapToDouble.
   example:  List<Integer> numbersList = Arrays.asList(1, 2, 3, 4, 5);
            IntStream b = numbersList.stream().mapToInt(Integer::intValue);

Conversely, you can convert a primitive-type stream to a regular Stream using methods like boxed().
    example:    IntStream intStream = Arrays.stream(intArray);
                List<Integer> resultList = intStream.boxed().collect(Collectors.toList());				 // Convert IntStream to Stream<Integer>

14. Default method 
	a default method is a method that can be defined in an interface with a body. It allow developers to add new methods to interfaces without breaking the 
	existing implementations of those interfaces. 
	for example: if i have a old interface with 2 methods, all the class which is implementing this interface should override these 2 methods. few months later if i 
		add another method to this interface, then the existing classes who have implemented this interface should override this new method also, if we dont do then the 
		implementing classes will break and throw errors. Therefore it is added for backward compatibility so that old interfaces can be used to leverage the lambda expression.
	For example, ‘List’ or ‘Collection’ interfaces do not have ‘forEach’ method declaration. Thus, adding such method will simply break the collection framework implementations
	example: Collection interface has below default method
		default Stream<E> stream() {
        return StreamSupport.stream(spliterator(), false);
    }

15. What is Static Keyword in Java
     static keyword is used for Memory Management

     The static keyword can be applied to:
     Variables: Static variables are initialized only once at the start of the program. If not explicitly initialized, they are assigned default 
                values (e.g., 0 for integers, null for objects). They are also known as class variables. 
                A single copy of a static variable is shared among all instances of the class. which helps in conserving memory when multiple instances of a class
                are created.
     Methods: Static methods and variables can be accessed directly using the class name and doesn't need any object. 
     Blocks: Static blocks are executed even before the main method is executed. They are also Known as static initialization blocks.
     Nested Classes: Static nested classes can be defined within a class.

     THIS and SUPER cannot be used in static contexts because they refer to instance-specific data. THIS refers to the current object, and SUPER refers to the superclass
     of the current object.

     Static methods cannot be overridden. If a subclass defines a static method with the same name and parameters as a static method in the superclass, 
     it is known as method hiding, not overriding. The method that gets called is determined by the reference type, not the object type. 

16. What is the abstraction?    HIDSOF
    Abstraction is a process of hiding the implementation details and showing only functionality to the user.  Abstraction enables you to focus on what the object does
   instead of how it does it. It can be achieved through abstract classes and interfaces in Java.

17. What is the difference between abstraction and encapsulation?
    Abstraction hides the implementation details whereas encapsulation wraps code and data into a single unit.
    The main purpose of encapsulation is to protect the internal state of an object and ensure that it can only be modified in controlled ways. 
    This enhances data integrity and security.
    Encapsulation is achieved using:
    Access Modifiers: Keywords like private, protected, and public that control the visibility of class members (variables and methods).
    Getters and Setters: Public methods that allow controlled access to private variables.

18.  What is the interface?
 The interface is a blueprint for a class that has only constants (static final variables) and abstract methods. It is used to achieve full abstraction and 
 multiple inheritance. There can be only abstract methods in the Java interface, not method body. Java Interface also represents the IS-A relationship. It cannot be
 instantiated just like the abstract class. However, we need to implement it to define its methods. Traditionally, interfaces could only contain abstract methods.
 However, since Java 8, interfaces can also include:
 Default Methods:  Methods with a body that can provide default behavior. Implementing classes can choose to override these methods.
 Static Methods:  Methods that belong to the interface itself and can be called without an instance of the interface.
 Private Methods:  Methods that can be used within the interface to share code between default methods.

19. What is a marker interface?
    A marker interface is an interface that does not contain any methods or fields. Its primary purpose is to provide metadata about a class to the 
    Java runtime or to other parts of the program. The syntax for it is like below
       public interface Serializable{ } 

   Common Examples of Marker Interfaces
     Serializable: Serializable interface indicates that its objects can be serialized (converted into a byte stream) and deserialized (reconstructed from a byte stream).
     Cloneable: Cloneable interface indicates that it allows its objects to be cloned (i.e., creating a copy of the object).
     Remote: In Java RMI (Remote Method Invocation), the Remote interface indicates that a class can be used to define remote objects.

20. Difference between StringBuffer and StringBuilder
       StringBuffer is thread-safe and suitable for multi-threaded environments but is slower due to synchronization.
       StringBuilder is not thread-safe but is faster and more efficient for single-threaded applications.

21. What is Garbage Collection?
     Garbage Collection (GC) in Java is an automatic memory management process that helps in reclaiming memory by removing objects that are no longer in use or reachable
     in a program. This process is to ensure efficient memory usage in applications. 
     GC is automatic, meaning that developers do not need to manually free memory. The Java Virtual Machine (JVM) handles this process, allowing developers to focus
     on application logic rather than memory management.
     Garbage Collection (GC) runs periodically and can be triggered by various factors, such as memory pressure or explicit requests from the application.
     Memory Management:  In Java, memory is divided into several areas, primarily the Heap and the Stack. The Heap is where objects are allocated, while the Stack is
                         used for method calls and local variables. When an object is created, memory is allocated for it in the Heap. Once there are no references to
                         that object, it becomes eligible for garbage collection. 

     Types of Garbage Collection
         1.  Serial Garbage Collector: A simple, single-threaded garbage collector that is suitable for small applications with a single thread. It pauses all 
             application threads during garbage collection.
         2. Parallel Garbage Collector: A multi-threaded garbage collector that uses multiple threads to perform garbage collection in parallel. It is suitable
            for applications that require high throughput.

     Garbage Collection Process - The garbage collection process generally involves the following steps:
         Marking: The garbage collector identifies which objects are reachable and marks all reachable objects.
         Sweeping: After marking, the garbage collector sweeps through the heap and collects all unmarked (unreachable) objects, reclaiming their memory.
         Compacting (optional): In some garbage collection algorithms, the memory is compacted to reduce fragmentation. This involves moving reachable objects
                                together to create contiguous free space.

     Important Methods Related to Garbage Collection
          1. System.gc(): The System.gc() method is a request to the JVM to perform garbage collection. However, it depends upon the JVM whether to perform it or not.
          2. finalize():  This is a protected method of the Object class that can be overridden by a class to perform cleanup operations before an object is 
                          garbage collected. The finalize() method is called by the garbage collector when it determines that there are no more references to the object.

              example:
              @Override
               protected void finalize() throws Throwable {
                       try {
                              // Cleanup code, e.g., closing resources
                              System.out.println("Object is being garbage collected");
                       } finally {
                            super.finalize(); 

22. What is the transient keyword?
 		If you define any data member as transient, it will not be serialized. By determining transient keyword, the value of variable need not persist when it is restored.

23. How to make a read-only class in Java?
    A class can be made read-only by making all of the fields private. The read-only class will have only getter methods which return the private property of the class
    to the main method

24.  How can we create an immutable class in Java?
     We can create an immutable class by defining a final class having all of its members as final

25. hashmap internal working
		Hashmap
		a. map doesnt maintain order, hashmap initial capacity is 16, using this value node array of size 16 is created. we can have 1 null key whose index will be zero in bucket
		b. hashcode is generated for keys using their ascii codes
		c. index is generated from hashcode using modulo 10 etc.
		d. this index is used to determine location of the value to be stored in bucket/node type array
		e. Node is a nested class within hashmap class. A node array is created with size 16 because default initial capacity of node array is 16
		f. The node structure is like     [ hashcode, key, value, null ]
		. when collision occurs due to getting same index from hashcode, then a linkedlist is created on same index & elements are stored
		. maximum 8 collisions are allowed to create linked list in a single index, if collisions > 8, then a Balanced tree(Red black tree) is created
		 



