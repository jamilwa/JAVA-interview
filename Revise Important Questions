1.                  Array                                                                          Arraylist 
    Array is static in size.	                                                	ArrayList is dynamic in size.
    It is mandatory to provide the size of an array while using new keyword     	We can create an instance of ArrayList without specifying its size. 
     ex:   int[] myArray = new int[6];                                              	 initial capacity is 10.
           myArray[0] = 3;
    It performs fast because of fixed size.	                                		The resize operation slows down the performance.
    length variable to determine the size of an array.	                        	size() method to determine the size of ArrayList.
    stores both objects and primitives type.	                                	doesn't store primitive type. It automatically converts primitive type to object.
    can add elements in an array by using the assignment operator.	        		the add() method to add elements in the ArrayList.
    throws ArrayIndexOutofBoundException											                  throws IndexOutofBoundException


2. Arrays class methods are    (ABCDES) ---- Array BinarySearch CopyOf DeepToString Equals Sort
int[] numbers = {1, 2, 3, 7, 4, 5};
 void       Arrays.sort(numbers);                          // Output: [1, 2, 3, 4, 5, 7]
               Arrays.sort(numbers[], Comparator.reverseOrder())           // Sorting the array in descending order. note: it works on object like Integer not on int.
               Arrays.sort(numbers, 3,5);                                 // sorts only numbers falling between fromIndex 3 and toIndex 5

int[] copy = Arrays.copyOf(numbers, 3);
               Arrays.toString(copy));                         // Output: [1, 2, 3]

 Arrays.binarySearch(numbers, 3);                  // output:  2 which is the index position of the value 3

3. Access modifiers
        Default (Package-Private): accessible only within its own package.    DOP
        Protected: accessible in subclasses of other packages.  ProSOP

4. How to make collection threadsafe
	1. Using Synchronized Collections : Java provides synchronized wrappers for collections through the Collections.synchronizedXXX methods like 
		Collections.synchronizedList(), Collections.synchronizedSet(), Collections.synchronizedMap.
    examplee:   
    	List<Integer> list = Collections.synchronizedList(new ArrayList<>());

  2. Using Concurrent Collections : Java provides a set of concurrent collections in the java.util.concurrent package. 
	example:
		ConcurrentHashMap: A thread-safe variant of HashMap that allows concurrent read and write operations.
		CopyOnWriteArrayList: A thread-safe variant of ArrayList where all mutative operations (like add, set, etc.) are implemented by making a fresh copy
					of the underlying array.
		ConcurrentSkipListSet: This is a thread-safe variant of NavigableSet that uses a skip list for its underlying data structure. It allows concurrent 
					access and maintains a sorted order.
		BlockingQueue: An interface that represents a thread-safe queue that supports operations that wait for the queue to become non-empty when retrieving 
					an element and wait for space to become available in the queue when storing an element.
	3. Using ThreadLocal : If you want to maintain a separate instance of a collection for each thread, you can use ThreadLocal. This is useful when you want to
				avoid contention between threads.

5. if we have Collection.SynchronizedMap() then why to use concurrentHashmap
	Collections.synchronizedMap(): Provides serial access, meaning only one thread can access the map at a time for read or write operations. This can lead to
				       increased waiting times and reduced performance when multiple threads are involved.
				       Supports null keys and values, depending on the underlying map implementation.
				       The iterator is fail-fast, meaning it throws a ConcurrentModificationException if the map is modified while iterating
				       Suitable for applications where data consistency is more critical than performance.
	ConcurrentHashMap: Allows multiple threads to read and write concurrently. It uses a segmented locking mechanism, which means that only a portion of the map
				is locked during write operations, allowing for higher throughput.
				Does not allow null keys or values, which helps avoid ambiguity in concurrent environments.
				The iterator is fail-safe, allowing modifications during iteration without throwing exceptions.
				Ideal for high-performance applications where multiple threads frequently read and write data.

6.   			                      ArrayList				              LinkedList

structure                uses a dynamic array	                uses a doubly linked list.
Access                   Fast (O1)				                    Slow (On)
Insert/Delete in middle  Slow (On)                            Faster  
Memory                   Low                                  High
Iteration                Fast because contiguous memory       Slower becuase scattered nodes in memory 

7. Comparator
class Employee {
    String name;
    int age;

    // add Constructor, setter, getter and tostring
}

class AgeComparator implements Comparator<Employee> {
    @Override
    public int compare(Employee e1, Employee e2) {
        return Integer.compare(e1.age, e2.age); // Compare by age
    }
}

class NameComparator implements Comparator<Employee> {
    @Override
    public int compare(Employee e1, Employee e2) {
        // Compare by name in lexicographical order
        return e1.name.compareTo(e2.name);
    }
}

public class Main {
    public static void main(String[] args) {
        List<Employee> employees = Arrays.asList(new Employee("Alice", 30), new Employee("Charlie", 35), new Employee("Bob", 25), new Employee("Bob", 20) );

        Collections.sort(employees, new NameComparator());     				// is used if there are no setters and getters, but only constructor is there.
		System.out.println(employees); 						// output [Alice (30), Bob (25), Bob (20), Charlie (35)]

        Collections.sort(employees, Comparator.comparing(Employee::getName)); 
		System.out.println(employees); 						// output [Alice (30), Bob (25), Bob (20), Charlie (35)]

        Collections.sort(employees, Comparator.comparing(Employee::getName).thenComparing(Employee::getAge));        
		System.out.println(employees); 						// output [Alice (30), Bob (20), Bob (25), Charlie (35)]

        Collections.sort(employees, Comparator.comparing(Employee::getName, Comparator.reverseOrder())
      .thenComparing(Employee::getAge, Comparator.reverseOrder())); 
		System.out.println(employees); 						// output [Charlie (35), Bob (25), Bob (20), Alice (30)]


	if Comparator is not to be used in Collections.sort() by name & then by age, then we can make use of below code to do sorting
	
	class EmployeeComparator implements Comparator<Employee> {
	 
	    @Override
	    public int compare(Employee e1, Employee e2)
	    {
		// 1st level comparison
	        int NameCompare = e1.getName().compareTo(e2.getName());
	        int AgeCompare = Integer.compare(e1.Age, e2.Age);
	 
	        // 2nd level comparison
	        return (NameCompare == 0) ? AgeCompare : NameCompare;
		}

		and in main class use below
		Collections.sort(employees, new EmployeeComparator());

8. What is Functional Programming
	a programming style that uses pure functions to solve problems. It emphasizes writing concise, readable code that's easier to maintain and Test. it eliminates
	the need of anonymous class and gives a functional programming capability to Java. 
	Lambda expressions are used to define implementation of a functional interface.

		Types of Functional Interfaces
	Java provides several built-in functional interfaces in the java.util.function package.
	1. Predicate : The Predicate interface is often used for filtering and matching conditions.
		Description: Represents a function that takes one argument and returns a boolean.
		Method: boolean test(T t)
		
		Example:  filter()
			Predicate<String> isEmpty = str -> str.isEmpty();
			System.out.println(isEmpty.test("")); // true

	2. Function
		Description: Represents a function that takes one argument and produces a result.
		Method: R apply(T t)
		
		Example: map, flatmpa,sorted, disticnt
			Function<String, Integer> stringLength = str -> str.length();
			System.out.println(stringLength.apply("Hello")); // 5

	3. Consumer
		Description: Represents an function that takes a one argument and returns no result. It is used for operations that consume data.
		Method: void accept(T t)
		
		Example:   forEach, Peek
			Consumer<String> print = str -> System.out.println(str);
			print.accept("Hello, World!"); // Prints: Hello, World!

	4. Supplier
		Description: Represents a supplier of results. It does not take any arguments and returns a result.
		Method: T get()

		Example:
			Supplier<String> supplier = () -> "Hello, Supplier!";
			System.out.println(supplier.get()); // Hello, Supplier!

	5. UnaryOperator
		Description: Represents a function that takes a single argument of type T and returns a result of the same type.
		Method: T apply(T t)

		Example:
			UnaryOperator<Integer> square = x -> x * x;
			System.out.println(square.apply(5)); // 25

	6. BinaryOperator
		Description: Represents a function that takes two arguments of the same type and returns a result of the same type.
		Method: T apply(T t1, T t2)

		Example:
			BinaryOperator<Integer> add = (a, b) -> a + b;
			System.out.println(add.apply(5, 10)); // 15

9.  A method reference can be used to point the following types of methods âˆ’
Static methods
Instance methods
Constructors using new operator (TreeSet::new)

10. Optional - Optional class is a container object that may or may not contain a value. It was introduced as part of the import java.util.Optional; package to help
		developers avoid NullPointerExceptions and to provide a more expressive way to handle optional values.

	Creating an Optional: -You can create an Optional instance in several ways:
	1. Empty Optional:  Optional<String> emptyOptional = Optional.empty();			// it creates an empty Optional instance, it does not contain a value
	2. Optional with a Non-null Value: Optional<String> nonNullOptional = Optional.of("Hello, World!");	// it creates an Optional with a non-null value. If the
															value is null, it throws a NullPointerException
	3. Optional that Allows Null Values:	Optional<String> nullableOptional = Optional.ofNullable(null); 		// it creates an Optional that can hold a value 
															that may be null. If the value is null, it creates 
															an empty Optional


	Common Methods of Optional  (Get IfOrElse MapIsFlat)
	1. isPresent(): Checks if a value is present.
		Optional<String> optional = Optional.of("Hello");
		if (optional.isPresent()) {
    			System.out.println(optional.get()); // Prints: Hello
		}
	
	2. ifPresent(Consumer<? super T> action): Executes the given action if a value is present.
		optional.ifPresent(value -> System.out.println(value)); // Prints: Hello

	3. get(): Returns the value if present; otherwise, it throws NoSuchElementException.
		String value = optional.get(); // Returns "Hello"

	4. orElse(T other): Returns the value if present; otherwise, returns the provided default value.
		String value = emptyOptional.orElse("Default Value"); // Returns "Default Value"

	5. orElseGet(Supplier<? extends T> other): Returns the value if present; otherwise, invokes the provided supplier and returns the result.
		String value = emptyOptional.orElseGet(() -> "Generated Value"); // Returns "Generated Value"

	6. orElseThrow(Supplier<? extends X> exceptionSupplier): Returns the value if present; otherwise, throws an exception created by the provided supplier.
		String value = emptyOptional.orElseThrow(() -> new IllegalArgumentException("Value is absent"));

	7. map(Function<? super T, ? extends U> mapper): If a value is present, applies the provided mapping function to it and returns an Optional describing the result.
		Optional<Integer> lengthOptional = optional.map(String::length); // Returns Optional[5]

	8. flatMap(Function<? super T, Optional<U>> mapper): Similar to map, but the mapping function must return an Optional
		Optional<String> optionalValue = Optional.of("Hello");
		Optional<Integer> lengthOptional = optionalValue.flatMap(value -> Optional.of(value.length())); // Returns Optional[5]


11. Collectors (Collectors Group Joining parti, toList counting summarizingInt) 
12. List of Terminal Operations in Streams (ColCouToA, ReSuMa, NoneAllAny, SummrayforEa)
13. why do we use IntStream
        the Stream API is designed to work with objects, not primitive types directly. However, the Stream API provides special primitive-type streams to handle
        primitive values such as 
                1. IntStream: A stream of primitive ints. the methods of InstStream are
					sum, average, min, count, summaryStatistics
				example: int sum = IntStream.of(numbers).sum();

example:   int[] intArray = {1, 2, 3, 4, 5};
           IntStream a = Arrays.stream(intArray);        // Using IntStream
           int sum = a.sum();           				// Example operations on IntStream
You can convert a regular Stream to a primitive-type stream using methods like mapToInt, mapToLong, or mapToDouble.
   example:  List<Integer> numbersList = Arrays.asList(1, 2, 3, 4, 5);
            IntStream b = numbersList.stream().mapToInt(Integer::intValue);

Conversely, you can convert a primitive-type stream to a regular Stream using methods like boxed().
    example:    IntStream intStream = Arrays.stream(intArray);
                List<Integer> resultList = intStream.boxed().collect(Collectors.toList());				 // Convert IntStream to Stream<Integer>

14. 


